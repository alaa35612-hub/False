// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© OpenAI

//@version=5
indicator(title = "ICT - Internal Range Liquidity MSS Engine", overlay = true, max_bars_back = 5000, max_lines_count = 500, max_boxes_count = 500, max_labels_count = 500)

// =============== Inputs
input_group_tf = "Timeframes"
htf_tf = input.timeframe("15", "HTF Bias TF", group = input_group_tf)
ltf_tf = input.timeframe("1", "Execution TF (LTF)", group = input_group_tf, tooltip = "LTF is used for alerts/context only; run the script on your execution timeframe for signals.")

input_group_pivots = "Pivots"
pivot_left = input.int(3, "Pivot left", minval = 1, group = input_group_pivots)
pivot_right = input.int(3, "Pivot right", minval = 1, group = input_group_pivots)

input_group_liq = "BSL/SSL Liquidity"
repeat_count = input.int(2, "Repeat count for BSL/SSL", minval = 2, group = input_group_liq)
price_tolerance_pct = input.float(0.15, "Price tolerance (%)", minval = 0.01, step = 0.01, group = input_group_liq, tooltip = "Percentage tolerance for matching levels.")
time_tolerance_bars = input.int(8, "Time tolerance (bars)", minval = 1, group = input_group_liq)
maxDisplayedLevels = input.int(6, "Max levels on chart", minval = 1, group = input_group_liq)
require_wick = input.bool(true, "Require wick penetration", group = input_group_liq, tooltip = "If true, wick must pierce the level to count as a raid.")

input_group_mss = "MSS"
show_mss = input.bool(true, "Show MSS", group = input_group_mss)

input_group_fvg = "FVG / OB"
maxFvgsOnChart = input.int(6, "Max FVG/OB zones", minval = 1, group = input_group_fvg)

input_group_bias = "Bias"
biasLockBars = input.int(3, "Bias lock bars", minval = 0, group = input_group_bias)

input_group_risk = "Risk Management"
buffer = input.float(0.5, "SL buffer (ticks/pts)", minval = 0, group = input_group_risk)
rr = input.float(2.0, "Risk:Reward default", minval = 0.1, step = 0.1, group = input_group_risk)
tp_mode = input.string("FixedRR", "TP Mode", options = ["OppositeLiquidity", "FixedRR", "StructureLevel"], group = input_group_risk)

input_group_alerts = "Alerts"
alert_on_mss = input.bool(true, "Enable MSS alerts", group = input_group_alerts)
alert_on_entry = input.bool(true, "Enable entry alerts", group = input_group_alerts)
alert_on_raids = input.bool(true, "Enable raid alerts", group = input_group_alerts)
alert_msg_mss = input.string("MSS detected", "MSS alert message", group = input_group_alerts)
alert_msg_entry = input.string("Entry signal", "Entry alert message", group = input_group_alerts)
alert_msg_raid = input.string("Liquidity raid", "Raid alert message", group = input_group_alerts)

// =============== Types

// Liquidity level for BSL/SSL
type LiquidityLevel
    float price
    int time
    string level_type
    bool raided
    line line_id
    label label_id

// Candidate for building liquidity levels
type LiquidityCandidate
    float price
    int first_time
    int count
    string level_type

// MSS signal
type MSSSignal
    string direction
    int bar_index_confirm
    float price
    bool confirmed
    label label_id

// FVG Zone
type FvgZone
    float top
    float bot
    int created_bar
    box box_id
    bool valid
    string direction

// OB Zone
type ObZone
    float top
    float bot
    int created_bar
    box box_id
    bool valid
    string direction

// Entry Signal
type EntrySignal
    int bar_index_signal
    string direction
    float entry_price
    float sl_price
    float tp_price
    label label_id
    line sl_line
    line tp_line

// =============== State containers
var array<LiquidityLevel> levels = array.new<LiquidityLevel>()
var array<LiquidityCandidate> candidates = array.new<LiquidityCandidate>()
var array<FvgZone> fvg_zones = array.new<FvgZone>()
var array<ObZone> ob_zones = array.new<ObZone>()

var float lastSwingHigh = na
var float lastSwingLow = na
var string lastRaidType = ""
var bool lastRaidReady = false
var MSSSignal lastMss = MSSSignal.new("", na, na, false, na)
var int biasLockCounter = 0
var int lastBias = 0

// =============== Helper logic (no global mutation in functions)
priceWithinTolerance(basePrice, testPrice, tolerancePct) =>
    float delta = math.abs(basePrice - testPrice)
    float allowed = basePrice * (tolerancePct / 100.0)
    delta <= allowed

// =============== BSL/SSL detection (Liquidity)

pivotHigh = ta.pivothigh(high, pivot_left, pivot_right)
pivotLow = ta.pivotlow(low, pivot_left, pivot_right)

if not na(pivotHigh)
    int pivotBar = bar_index - pivot_right
    float pivotPrice = pivotHigh
    bool matched = false
    for idx = 0 to array.size(candidates) - 1
        LiquidityCandidate c = array.get(candidates, idx)
        if c.level_type == "BSL" and (bar_index - c.first_time) <= time_tolerance_bars and priceWithinTolerance(c.price, pivotPrice, price_tolerance_pct)
            c.count += 1
            array.set(candidates, idx, c)
            matched := true
            if c.count >= repeat_count
                line newLine = line.new(c.first_time, c.price, bar_index, c.price, extend = extend.right, color = color.red, style = line.style_dotted, width = 1)
                label newLabel = label.new(c.first_time, c.price, "BSL", color = color.new(color.red, 0), textcolor = color.white, style = label.style_label_left)
                LiquidityLevel lvl = LiquidityLevel.new(c.price, c.first_time, "BSL", false, newLine, newLabel)
                array.push(levels, lvl)
                array.remove(candidates, idx)
                break
    if not matched
        LiquidityCandidate c = LiquidityCandidate.new(pivotPrice, pivotBar, 1, "BSL")
        array.push(candidates, c)

if not na(pivotLow)
    int pivotBar = bar_index - pivot_right
    float pivotPrice = pivotLow
    bool matched = false
    for idx = 0 to array.size(candidates) - 1
        LiquidityCandidate c = array.get(candidates, idx)
        if c.level_type == "SSL" and (bar_index - c.first_time) <= time_tolerance_bars and priceWithinTolerance(c.price, pivotPrice, price_tolerance_pct)
            c.count += 1
            array.set(candidates, idx, c)
            matched := true
            if c.count >= repeat_count
                line newLine = line.new(c.first_time, c.price, bar_index, c.price, extend = extend.right, color = color.green, style = line.style_dotted, width = 1)
                label newLabel = label.new(c.first_time, c.price, "SSL", color = color.new(color.green, 0), textcolor = color.white, style = label.style_label_left)
                LiquidityLevel lvl = LiquidityLevel.new(c.price, c.first_time, "SSL", false, newLine, newLabel)
                array.push(levels, lvl)
                array.remove(candidates, idx)
                break
    if not matched
        LiquidityCandidate c = LiquidityCandidate.new(pivotPrice, pivotBar, 1, "SSL")
        array.push(candidates, c)

// Manage level limit
if array.size(levels) > maxDisplayedLevels
    LiquidityLevel lvl = array.shift(levels)
    if not na(lvl.line_id)
        line.delete(lvl.line_id)
    if not na(lvl.label_id)
        label.delete(lvl.label_id)

// =============== Raid detection
for idx = 0 to array.size(levels) - 1
    LiquidityLevel lvl = array.get(levels, idx)
    if not lvl.raided
        bool wickRaid = lvl.level_type == "BSL" ? high > lvl.price : low < lvl.price
        bool bodyRaid = lvl.level_type == "BSL" ? close > lvl.price : close < lvl.price
        bool raidCondition = (require_wick ? wickRaid : true) and bodyRaid
        if raidCondition
            lvl.raided := true
            lastRaidType := lvl.level_type
            lastRaidReady := true
            if not na(lvl.line_id)
                line.set_color(lvl.line_id, color.gray)
                line.set_style(lvl.line_id, line.style_dashed)
            if not na(lvl.label_id)
                label.delete(lvl.label_id)
            label raidLabel = label.new(bar_index, lvl.price, "Raid", style = label.style_label_down, color = color.new(color.orange, 0), textcolor = color.black)
            lvl.label_id := raidLabel
            array.set(levels, idx, lvl)
            if alert_on_raids
                alert(alert_msg_raid + " | " + syminfo.ticker + " | " + timeframe.period + " | " + lvl.level_type + " | " + str.tostring(lvl.price), alert.freq_once_per_bar)

// =============== MSS detection (after raid)
if not na(pivotHigh)
    lastSwingHigh := pivotHigh
if not na(pivotLow)
    lastSwingLow := pivotLow

bool bullishMss = false
bool bearishMss = false

if lastRaidReady and lastRaidType == "SSL" and not na(lastSwingHigh)
    bullishMss := close > lastSwingHigh
if lastRaidReady and lastRaidType == "BSL" and not na(lastSwingLow)
    bearishMss := close < lastSwingLow

if bullishMss
    lastMss := MSSSignal.new("bullish", bar_index, close, true, na)
    lastRaidReady := false
    if show_mss
        label mssLabel = label.new(bar_index, close, "ðŸ”¼", style = label.style_label_up, color = color.new(color.green, 0), textcolor = color.white)
        lastMss.label_id := mssLabel
    if alert_on_mss
        alert(alert_msg_mss + " | " + syminfo.ticker + " | " + timeframe.period + " | bullish | " + str.tostring(close), alert.freq_once_per_bar)

if bearishMss
    lastMss := MSSSignal.new("bearish", bar_index, close, true, na)
    lastRaidReady := false
    if show_mss
        label mssLabel = label.new(bar_index, close, "ðŸ”½", style = label.style_label_down, color = color.new(color.red, 0), textcolor = color.white)
        lastMss.label_id := mssLabel
    if alert_on_mss
        alert(alert_msg_mss + " | " + syminfo.ticker + " | " + timeframe.period + " | bearish | " + str.tostring(close), alert.freq_once_per_bar)

// =============== HTF Bias (MTF)
htfBiasRaw = request.security(syminfo.tickerid, htf_tf, () =>
    float ph = ta.pivothigh(high, pivot_left, pivot_right)
    float pl = ta.pivotlow(low, pivot_left, pivot_right)
    float lastPh = ta.valuewhen(not na(ph), ph, 0)
    float prevPh = ta.valuewhen(not na(ph), ph, 1)
    float lastPl = ta.valuewhen(not na(pl), pl, 0)
    float prevPl = ta.valuewhen(not na(pl), pl, 1)
    int bias = lastPh > prevPh and lastPl > prevPl ? 1 : lastPh < prevPh and lastPl < prevPl ? -1 : 0
    bias
)

if htfBiasRaw != lastBias
    if biasLockCounter == 0
        lastBias := htfBiasRaw
        biasLockCounter := biasLockBars
    else
        biasLockCounter -= 1
else
    if biasLockCounter > 0
        biasLockCounter -= 1

string htfBias = lastBias == 1 ? "bullish" : lastBias == -1 ? "bearish" : "neutral"

// =============== FVG & OB after MSS

bool canCreateZones = lastMss.confirmed and ((lastMss.direction == "bullish" and htfBias == "bullish") or (lastMss.direction == "bearish" and htfBias == "bearish"))

if canCreateZones
    // FVG detection
    bool bullishFvg = low > high[2]
    bool bearishFvg = high < low[2]
    if bullishFvg and lastMss.direction == "bullish"
        float top = low
        float bot = high[2]
        box fvgBox = box.new(bar_index - 2, top, bar_index, bot, bgcolor = color.new(color.green, 85), border_color = color.new(color.green, 40), extend = extend.right)
        FvgZone fvg = FvgZone.new(top, bot, bar_index, fvgBox, true, "bullish")
        array.push(fvg_zones, fvg)
    if bearishFvg and lastMss.direction == "bearish"
        float top = low[2]
        float bot = high
        box fvgBox = box.new(bar_index - 2, top, bar_index, bot, bgcolor = color.new(color.red, 85), border_color = color.new(color.red, 40), extend = extend.right)
        FvgZone fvg = FvgZone.new(top, bot, bar_index, fvgBox, true, "bearish")
        array.push(fvg_zones, fvg)

    // OB detection (last opposite candle)
    int lastOppIndex = lastMss.direction == "bullish" ? ta.valuewhen(close < open, bar_index, 0) : ta.valuewhen(close > open, bar_index, 0)
    float lastOppOpen = lastMss.direction == "bullish" ? ta.valuewhen(close < open, open, 0) : ta.valuewhen(close > open, open, 0)
    float lastOppClose = lastMss.direction == "bullish" ? ta.valuewhen(close < open, close, 0) : ta.valuewhen(close > open, close, 0)
    if not na(lastOppIndex)
        float top = math.max(lastOppOpen, lastOppClose)
        float bot = math.min(lastOppOpen, lastOppClose)
        box obBox = box.new(lastOppIndex, top, lastOppIndex + 1, bot, bgcolor = color.new(color.blue, 85), border_color = color.new(color.blue, 40), extend = extend.right)
        ObZone ob = ObZone.new(top, bot, lastOppIndex, obBox, true, lastMss.direction)
        array.push(ob_zones, ob)

// Manage zone limits
while array.size(fvg_zones) > maxFvgsOnChart
    FvgZone fvg = array.shift(fvg_zones)
    if not na(fvg.box_id)
        box.delete(fvg.box_id)

while array.size(ob_zones) > maxFvgsOnChart
    ObZone ob = array.shift(ob_zones)
    if not na(ob.box_id)
        box.delete(ob.box_id)

// Invalidate zones if filled and closed outside
for idx = 0 to array.size(fvg_zones) - 1
    FvgZone fvg = array.get(fvg_zones, idx)
    if fvg.valid
        bool touched = low <= fvg.top and high >= fvg.bot
        bool closedOutside = close > fvg.top or close < fvg.bot
        if touched and closedOutside
            fvg.valid := false
            if not na(fvg.box_id)
                box.delete(fvg.box_id)
            array.set(fvg_zones, idx, fvg)

for idx = 0 to array.size(ob_zones) - 1
    ObZone ob = array.get(ob_zones, idx)
    if ob.valid
        bool touched = low <= ob.top and high >= ob.bot
        bool closedOutside = close > ob.top or close < ob.bot
        if touched and closedOutside
            ob.valid := false
            if not na(ob.box_id)
                box.delete(ob.box_id)
            array.set(ob_zones, idx, ob)

// =============== Entry/Exit logic

float lastLiquidityPrice = na
string lastLiquidityType = ""
for idx = 0 to array.size(levels) - 1
    LiquidityLevel lvl = array.get(levels, idx)
    if lvl.raided
        lastLiquidityPrice := lvl.price
        lastLiquidityType := lvl.level_type

bool bullishEntry = htfBias == "bullish" and lastLiquidityType == "SSL" and lastMss.confirmed and lastMss.direction == "bullish"
bool bearishEntry = htfBias == "bearish" and lastLiquidityType == "BSL" and lastMss.confirmed and lastMss.direction == "bearish"

bool fvgTouchedBull = false
bool fvgTouchedBear = false
for idx = 0 to array.size(fvg_zones) - 1
    FvgZone fvg = array.get(fvg_zones, idx)
    if fvg.valid and fvg.direction == "bullish"
        if low <= fvg.top and high >= fvg.bot
            fvgTouchedBull := true
    if fvg.valid and fvg.direction == "bearish"
        if low <= fvg.top and high >= fvg.bot
            fvgTouchedBear := true

bool obTouchedBull = false
bool obTouchedBear = false
for idx = 0 to array.size(ob_zones) - 1
    ObZone ob = array.get(ob_zones, idx)
    if ob.valid and ob.direction == "bullish"
        if low <= ob.top and high >= ob.bot
            obTouchedBull := true
    if ob.valid and ob.direction == "bearish"
        if low <= ob.top and high >= ob.bot
            obTouchedBear := true

bool entryBuy = bullishEntry and (fvgTouchedBull or obTouchedBull)
bool entrySell = bearishEntry and (fvgTouchedBear or obTouchedBear)

float entryPrice = close
float slPrice = na
float tpPrice = na

if entryBuy
    slPrice := lastLiquidityPrice - buffer
    tpPrice := tp_mode == "FixedRR" ? entryPrice + (entryPrice - slPrice) * rr : entryPrice + (entryPrice - slPrice)
    label entryLabel = label.new(bar_index, entryPrice, "BUY", style = label.style_label_up, color = color.new(color.green, 0), textcolor = color.white)
    line slLine = line.new(bar_index, slPrice, bar_index + 1, slPrice, extend = extend.right, color = color.red)
    line tpLine = line.new(bar_index, tpPrice, bar_index + 1, tpPrice, extend = extend.right, color = color.green)
    EntrySignal signal = EntrySignal.new(bar_index, "buy", entryPrice, slPrice, tpPrice, entryLabel, slLine, tpLine)
    if alert_on_entry
        alert(alert_msg_entry + " | " + syminfo.ticker + " | " + timeframe.period + " | BUY | " + str.tostring(entryPrice) + " | SL " + str.tostring(slPrice) + " | TP " + str.tostring(tpPrice), alert.freq_once_per_bar)

if entrySell
    slPrice := lastLiquidityPrice + buffer
    tpPrice := tp_mode == "FixedRR" ? entryPrice - (slPrice - entryPrice) * rr : entryPrice - (slPrice - entryPrice)
    label entryLabel = label.new(bar_index, entryPrice, "SELL", style = label.style_label_down, color = color.new(color.red, 0), textcolor = color.white)
    line slLine = line.new(bar_index, slPrice, bar_index + 1, slPrice, extend = extend.right, color = color.red)
    line tpLine = line.new(bar_index, tpPrice, bar_index + 1, tpPrice, extend = extend.right, color = color.green)
    EntrySignal signal = EntrySignal.new(bar_index, "sell", entryPrice, slPrice, tpPrice, entryLabel, slLine, tpLine)
    if alert_on_entry
        alert(alert_msg_entry + " | " + syminfo.ticker + " | " + timeframe.period + " | SELL | " + str.tostring(entryPrice) + " | SL " + str.tostring(slPrice) + " | TP " + str.tostring(tpPrice), alert.freq_once_per_bar)

// =============== Plots for debug
plotchar(htfBias == "bullish", title = "HTF Bias Bullish", char = "B", location = location.top, color = color.new(color.green, 0))
plotchar(htfBias == "bearish", title = "HTF Bias Bearish", char = "S", location = location.top, color = color.new(color.red, 0))
