// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © TeleHoaNo

//@version=5
indicator('PRO V6', shorttitle='PRO V6', max_lines_count=500, max_labels_count=500, max_bars_back=5000, overlay=true)

//---------------------------------------------------------------------------------------------------------------------
// Settings
//---------------------------------------------------------------------------------------------------------------------{
sp='         '
res   = input.timeframe (    ''   , 'Period        '                                )
i1        = input.bool  (   true  , ''            , inline='1', group='Swing Length')
i2        = input.bool  (   true  , ''            , inline='2', group='Swing Length')
i3        = input.bool  (   false  , ''            , inline='3', group='Swing Length')
l1        = input.int   (60, 'Long     ', minval=1, inline='1', group='Swing Length')
l2        = input.int   (30, 'Medium'   , minval=1, inline='2', group='Swing Length')
l3        = input.int   (10, 'Short    ', minval=1, inline='3', group='Swing Length')
cBull     = input.color (#05c926, 'Trendline'+sp, inline='d', group='Style'       )
cBear     = input.color (#ff0000, ''            , inline='d', group='Style'
          , tooltip    =            'Bullish/Bearish Trendline'                   )
cWickBull = input.color (#085def, 'Wick Dot' +sp, inline='w', group='Style'   )
cWickBear = input.color (#ff5d00, ''            , inline='w', group='Style'
          , tooltip    =            'Bullish/Bearish Wick'                   )
term      = input.string('Long'   , 'Term'
          , options    =['Long'   , 'Medium', 'Short'              ]     )
HHLL      = input.string('None'   , 'HH/LL'  
          , options    =['None','Only HH/LL','HH/LL & previous H/L'])
bg        = input.bool  (  false  , 'Background Color'        )
cc        = input.bool  (  false  , 'Bar Color'      )

//---------------------------------------------------------------------------------------------------------------------}
//LuxAlgo Defined Type
//---------------------------------------------------------------------------------------------------------------------{
type bin 
    line    lin 
    float   slope
    bool    active
    chart.point cp

//---------------------------------------------------------------------------------------------------------------------}
//Variables
//---------------------------------------------------------------------------------------------------------------------{
lbi = last_bar_index
n   = bar_index
INV = color(na)

//---------------------------------------------------------------------------------------------------------------------}
//Function
//---------------------------------------------------------------------------------------------------------------------{
draw(toggle, res, left, right, pos) =>

    ps = term == 'Long' ? 1 : term == 'Medium' ? 2 : 3

    var int trend    = 0
    var chart.point prevPh = chart.point.from_index(na, na)
    var chart.point prevPl = chart.point.from_index(na, na)

    var bn = bin.new(line(na), 0, false)

    ph_ = ta.pivothigh(left, right), [tH, ph]  = request.security(syminfo.tickerid, res, [time[2], ph_])
    pl_ = ta.pivotlow (left, right), [tL, pl]  = request.security(syminfo.tickerid, res, [time[2], pl_])

    cH = ta.change(fixnan(ph))    
    cL = ta.change(fixnan(pl))

    chH = cH != 0 and cL == 0
    chL = cL != 0 and cH == 0

    if toggle

        if bn.active 
            if bn.lin.get_x2() - bn.lin.get_x1() > 5000 
                bn.active := false 
                bn.lin.delete() 
            else 
                bn.lin.set_xy2(n, bn.lin.get_y2() + bn.slope)

        if chH 
            v = 0.
            idx = 0
            for i = 0 to 5000 
                Ti = time[i]
                if high[i] > v 
                    v := high[i]
                    idx := i
                if Ti < tH 
                    break
            x = n - idx
            c = close[idx]

            if trend < 1 
                //HH
                if v > prevPh.price and x - prevPh.index > 5 and n - prevPl.index < 5000
                    if pos == ps and HHLL != 'None'
                        label.new(x, v, color=color(na), text='HH\n', size=size.tiny, textcolor=chart.fg_color)
                        if HHLL == 'HH/LL & previous H/L'
                            label.new(prevPh.index, prevPh.price, color=color(na), size=size.tiny, text='●', textcolor=chart.fg_color)

                    trend := 1
                    bn := bin.new(line.new(prevPl.index, prevPl.price, n, prevPl.price, color=cBull
                     , style= pos == 1 ? line.style_solid : pos == 2 ? line.style_dashed : line.style_dotted, width=pos == 1 ? 2 : 2)
                     , 0, true, chart.point.from_index(prevPl.index, prevPl.price))
                else 
                    //if bearish TL
                    if bn.active
                        slope = (v - bn.cp.price) / (x - bn.cp.index)
                        //if line direction is down and wick breaks line or first LH
                        if v < bn.lin.get_y1() + slope and (v > bn.lin.get_y2() + slope or bn.slope == 0)
                            priceLin = bn.lin.get_price(n-idx) 
                            if c < priceLin
                                //where wick breaks last line price 
                                if bn.slope != 0
                                    label.new(n-idx, priceLin, style=label.style_label_center, text='●', color=color(na), textcolor=cWickBear)
                                //First update line
                                bn.lin.set_xy2(n, v + slope*idx)
                                //if first Swing after line conception
                                if bn.slope == 0
                                    //repeat until all close prices are below the line
                                    stop = false 
                                    while not stop
                                        arr = array.new<float>()
                                        //check for inner-line breaks with close
                                        for i = 0 to n - bn.lin.get_x1()
                                            arr.push(close[i] - bn.lin.get_price(n-i))
                                        highest_point = arr.max()
                                        //if yes, update first point to highest point
                                        if highest_point > 0
                                            ix = arr.indexof(highest_point)  
                                            x1 = n-ix, y1 = high[ix]
                                            //label.new(x1, y1)
                                            bn.cp.index := x1 
                                            bn.cp.price := y1
                                            slope  := (v - y1) / (x - x1)
                                            bn.lin.set_xy2(n, v + slope*idx)                                         
                                            bn.lin.set_xy1(x1, y1)
                                            bn.slope := slope
                                        else 
                                            bn.lin.set_xy2(n, v + slope*idx)                                         
                                            bn.slope := slope
                                            stop := true
                                else 
                                    bn.slope := slope
                            else 
                                //if close price at Swing point breaks line
                                bn.active := false
            prevPh.index := x
            prevPh.price := v

        else 
            if trend < 1 
                if close > bn.lin.get_y2() 
                    bn.active := false

        if chL 
            v = 10e6
            idx = 0
            for i = 0 to 5000 
                Ti = time[i]
                if low[i] < v 
                    v := low[i]
                    idx := i
                if Ti < tL
                    break
            x = n - idx
            c = close[idx]

            if trend >-1 
                //LL
                if v < prevPl.price and x - prevPl.index > 5 and n - prevPh.index < 5000
                    if pos == ps and HHLL != 'None'
                        label.new(x, v, color=color(na), text='\nLL', size=size.tiny, textcolor=chart.fg_color, style=label.style_label_up)
                        if HHLL == 'HH/LL & previous H/L'
                            label.new(prevPl.index, prevPl.price, color=color(na), size=size.tiny, text='●', textcolor=chart.fg_color, style=label.style_label_up)

                    trend :=-1
                    bn := bin.new(line.new(prevPh.index, prevPh.price, n, prevPh.price, color=cBear
                     , style= pos == 1 ? line.style_solid : pos == 2 ? line.style_dashed : line.style_dotted, width=pos == 1 ? 2 : 2)
                     , 0, true, chart.point.from_index(prevPh.index, prevPh.price))
                else 
                    //if bullish TL
                    if bn.active
                        slope = (v - bn.cp.price) / (x - bn.cp.index)
                        //if line direction is up and wick breaks line or first HL
                        if v > bn.lin.get_y1() + slope and (v < bn.lin.get_y2() + slope or bn.slope == 0)
                            priceLin = bn.lin.get_price(n-idx)

                            if c > priceLin 
                                //where wick breaks last line price 
                                if bn.slope != 0
                                    label.new(n-idx, priceLin, style=label.style_label_center, text='●', color=color(na), textcolor=cWickBull)
                                //First update line
                                bn.lin.set_xy2(n, v + slope*idx)
                                //if first Swing after line conception
                                if bn.slope == 0
                                    //repeat until all close prices are above the line
                                    stop = false 
                                    while not stop                                        
                                        arr = array.new<float>()
                                        //check for inner-line breaks with close
                                        for i = 0 to n - bn.lin.get_x1()
                                            arr.push(bn.lin.get_price(n-i)-close[i])
                                        deepest_point = arr.max()
                                        //if yes, update first point to deepest point
                                        if deepest_point > 0
                                            ix = arr.indexof(deepest_point)  
                                            x1 = n-ix, y1 = low[ix]
                                            bn.cp.index := x1 
                                            bn.cp.price := y1
                                            slope  := (v - y1) / (x - x1)
                                            bn.lin.set_xy2(n, v + slope*idx)                                         
                                            bn.lin.set_xy1(x1, y1)
                                            bn.slope := slope
                                        else
                                            bn.lin.set_xy2(n, v + slope*idx)                                         
                                            bn.slope := slope
                                            stop := true
                                else 
                                    bn.slope := slope
                            else 
                                //if close price at Swing point breaks line
                                bn.active := false
            prevPl.index := x
            prevPl.price := v
        else 
            if trend >-1 
                if close < bn.lin.get_y2() 
                    bn.active := false

    [trend, bn.lin.get_y2()]

//---------------------------------------------------------------------------------------------------------------------}
//Execution
//---------------------------------------------------------------------------------------------------------------------{
[trend1, value1] = draw(i1, res, l1, 1, 1)
[trend2, value2] = draw(i2, res, l2, 1, 2)
[trend3, value3] = draw(i3, res, l3, 1, 3)

col = color(na)
if cc 
    col := switch close > value1
        true => 
            switch close > value2
                true => 
                    if close > value3
                        color.new(cBull, 20)
                    else
                        color.new(cBull, 43)
                => 
                    if close > value3
                        color.new(cBull, 66)
                    else
                        color.new(cBull, 89)
        => 
            switch close < value2
                true => 
                    if close < value3
                        color.new(cBear, 20)
                    else
                        color.new(cBear, 43)
                => 
                    if close < value3
                        color.new(cBear, 66)
                    else
                        color.new(cBear, 89)

//---------------------------------------------------------------------------------------------------------------------}
//Plot - Bar/Background Color
//---------------------------------------------------------------------------------------------------------------------{
plot(value1, display=display.none)
plot(value2, display=display.none)
plot(value3, display=display.none)
plot(trend1, display=display.none)
barcolor(cc ? col : na)

//Background color - close above/below value1-2-3
isValid = bg and (term == 'Long' ? i1 : term == 'Medium' ? i2 : i3)
bgcolor(isValid ? color.new(close > (term == 'Long' ? value1 : term == 'Medium' ? value2 : value3) ? cBull : cBear, 97) : na)

//---------------------------------------------------------------------------------------------------------------------}

//@version=5


// Advanced multi-system trading indicator with comprehensive analysis

// ========== CHỈ BÁO 1: SIGNAL SYSTEM ==========
enable_signal_system = input.bool(true, title="━━━━━ Enable Signal System ━━━━━")
sensitivity = input.float(5, title='Signal Sensitivity', step=.5)
volatility_period = input(10, title='Volatility Period')

src = close
xATR = ta.atr(volatility_period)
nLoss = sensitivity * xATR

xSignalLine = 0.0
iff_1 = src > nz(xSignalLine[1], 0) ? src - nLoss : src + nLoss
iff_2 = src < nz(xSignalLine[1], 0) and src[1] < nz(xSignalLine[1], 0) ? math.min(nz(xSignalLine[1]), src + nLoss) : iff_1
xSignalLine := src > nz(xSignalLine[1], 0) and src[1] > nz(xSignalLine[1], 0) ? math.max(nz(xSignalLine[1]), src - nLoss) : iff_2

pos = 0
iff_3 = src[1] > nz(xSignalLine[1], 0) and src < nz(xSignalLine[1], 0) ? -1 : nz(pos[1], 0)
pos := src[1] < nz(xSignalLine[1], 0) and src > nz(xSignalLine[1], 0) ? 1 : iff_3

long_signal = enable_signal_system ? ta.crossover(src, xSignalLine) : false
short_signal = enable_signal_system ? ta.crossunder(src, xSignalLine) : false
barcolor_signal = src > xSignalLine

// ========== CHỈ BÁO 2: TREND FOLLOWING ==========
enable_trend_follow = input.bool(true, title="━━━━━ Enable Trend Following ━━━━━")
follow_type = input.string('enhanced', 'Follow Type', options=['enhanced', 'standard'])
trend_period = input(28, 'Trend Period')
trend_multiplier = input(5, 'Trend Multiplier')
show_zones = input(true, 'Show Entry Zones?')

norm_o = request.security(ticker.new(syminfo.prefix, syminfo.ticker), timeframe.period, open)
norm_h = request.security(ticker.new(syminfo.prefix, syminfo.ticker), timeframe.period, high)
norm_l = request.security(ticker.new(syminfo.prefix, syminfo.ticker), timeframe.period, low)
norm_c = request.security(ticker.new(syminfo.prefix, syminfo.ticker), timeframe.period, close)

// Enhanced moving average function
Enhanced_ma(_src, _malength) =>
    _enhanced = 0.0
    _enhanced := nz(_enhanced[1]) + (_src - nz(_enhanced[1])) / _malength
    _enhanced

// True range calculations
HiLo = math.min(norm_h - norm_l, 1.5 * nz(ta.sma(norm_h - norm_l, trend_period)))
HRef = norm_l <= norm_h[1] ? norm_h - norm_c[1] : norm_h - norm_c[1] - 0.5 * (norm_l - norm_h[1])
LRef = norm_h >= norm_l[1] ? norm_c[1] - norm_l : norm_c[1] - norm_l - 0.5 * (norm_l[1] - norm_h)

trueRange = follow_type == 'enhanced' ? math.max(HiLo, HRef, LRef) : math.max(norm_h - norm_l, math.abs(norm_h - norm_c[1]), math.abs(norm_l - norm_c[1]))

// Trend following logic
loss = trend_multiplier * Enhanced_ma(trueRange, trend_period)

Up = norm_c - loss
Dn = norm_c + loss

TrendUp = Up
TrendDown = Dn
Trend = 1

TrendUp := norm_c[1] > TrendUp[1] ? math.max(Up, TrendUp[1]) : Up
TrendDown := norm_c[1] < TrendDown[1] ? math.min(Dn, TrendDown[1]) : Dn

Trend := norm_c > TrendDown[1] ? 1 : norm_c < TrendUp[1] ? -1 : nz(Trend[1], 1)
trail = Trend == 1 ? TrendUp : TrendDown

ex = 0.0
ex := ta.crossover(Trend, 0) ? norm_h : ta.crossunder(Trend, 0) ? norm_l : Trend == 1 ? math.max(ex[1], norm_h) : Trend == -1 ? math.min(ex[1], norm_l) : ex[1]

// Entry zones
state = Trend == 1 ? 'up' : 'down'

zone1Level = 61.8
zone2Level = 78.6
zone3Level = 88.6

z1 = ex + (trail - ex) * zone1Level / 100
z2 = ex + (trail - ex) * zone2Level / 100
z3 = ex + (trail - ex) * zone3Level / 100
l100 = trail + 0

// Zone cross signals
z1_long = enable_trend_follow and state[1] == 'up' and ta.crossunder(norm_c, z1[1])
z2_long = enable_trend_follow and state[1] == 'up' and ta.crossunder(norm_c, z2[1])
z3_long = enable_trend_follow and state[1] == 'up' and ta.crossunder(norm_c, z3[1])
z1_short = enable_trend_follow and state[1] == 'down' and ta.crossover(norm_c, z1[1])
z2_short = enable_trend_follow and state[1] == 'down' and ta.crossover(norm_c, z2[1])
z3_short = enable_trend_follow and state[1] == 'down' and ta.crossover(norm_c, z3[1])

// ========== CHỈ BÁO 3: THEIL-SEN ESTIMATOR ==========
enable_theilsen = input.bool(false, title="━━━━━ Enable Theil-Sen Estimator ━━━━━")

// Theil-Sen parameters
ts_len = input.int(title='TS Length', defval=100, minval=3, maxval=400)
ts_src = input(title='TS Source', defval=close)
ts_method = input.string(title='Pair Selection Method', defval='All', options=['All', 'Random'])
ts_numpairs = input.int(title='Number of Pairs (if Method == Random)', defval=500, minval=3)
ts_showinterval = input(title='Show Prediction Interval', defval=true)
ts_mult = input.float(title='Prediction Interval Multiplier', defval=2, minval=0.1)
ts_showresult = input(title='Show Slope and Intercept', defval=false)
ts_colup = input(title='Color Up', defval=color.green)
ts_coldw = input(title='Color Down', defval=color.red)
ts_colbr = input(title='Channel Break Color', defval=color.orange)
ts_lw = input(title='Line Width', defval=2)
ts_extendln = input(title='Extend Line', defval=true)

// --- Theil-Sen subroutines ---
allslopes(_n, _y) =>
    // Get slopes for all pairs of _n data points 
    // _n :: number of points
    // _y :: source time series, e.g. close
    _S = array.new_float(0)
    if _n > 2
        for i = 0 to _n - 2 by 1
            for j = i + 1 to _n - 1 by 1
                array.push(_S, (_y[i] - _y[j]) / (j - i))
    _S

rndslopes(_S, _numpoints) =>
    // Get _numpoints random slopes from array _S
    // _Srnd :: output array
    _Srnd = array.new_float(0)
    int _ntmp = array.size(_S)
    int _n = _ntmp > _numpoints ? _numpoints : _ntmp
    int _i = 0
    int _s1 = 0
    int _s2 = 0
    int _s3 = 0
    float _rnd = na
    if _n > 2
        for k = 0 to _n - 1 by 1
            // use Wichmann–Hill pseudo-random number generator
            // initial seed values (should be random integer from 0 to 30,000)
            _s1 := k * int(ohlc4[1])
            _s1 := k * int(ohlc4[1] + ohlc4[2])
            _s3 := k * int(ohlc4[3])
            // generate uniformly distr _rnd (between 0 and 1)
            _s1 := 171 * (_s1 % 30269)
            _s2 := 172 * (_s2 % 30269)
            _s3 := 170 * (_s3 % 30269)
            _rnd := (float(_s1) / 30269.0 + float(_s2) / 30307.0 + float(_s3) / 30323.0) % 1
            _i := int(_rnd * _ntmp)
            // Add element to _Srnd
            array.push(_Srnd, array.get(_S, _i))
            // drop chosen element
            array.remove(_S, _i)
            _ntmp -= 1
            _ntmp
    _Srnd

intercepts(_src, _n, _mslope) =>
    // Get all intercepts (Y - mslope*X) 
    // _n :: number of data points
    // _mslope :: median slope determined by means of TS model
    _I = array.new_float(0)
    if _n > 2
        for i = 0 to _n - 1 by 1
            array.push(_I, _src[_n - 1 - i] - _mslope * i)
    _I

truncate(_value, _decimals) =>
    // For output: Truncates a given float to a certain number of decimals
    _factor = math.pow(10, _decimals)
    int(_value * _factor) / _factor

rmsd(_src, _x, _a, _b, _n) =>
    float _rmsd = 0.0
    for i = 0 to _n - 1 by 1
        _rmsd += math.pow(_src[i] - _a - _b * (_x - i), 2) / _n
        _rmsd
    math.sqrt(_rmsd)

// Theil-Sen calculations
ts_current_len = enable_theilsen ? ts_len : 0

// get TS estimate only for the last barstate
if not barstate.islast
    ts_current_len := 0
    ts_current_len

S = allslopes(ts_current_len, ts_src)
if ts_method == 'Random'
    S := rndslopes(S, ts_numpairs)
    S
mslope = array.median(S)
I = intercepts(ts_src, ts_current_len, mslope)
minter = array.median(I)

// apply estimator
ts_x = bar_index
ts_x1 = ts_x - ts_current_len
ts_x2 = ts_x
ts_y1 = minter
ts_y2 = minter + mslope * (ts_current_len - 1)

//estimate prediction interval (as \pm mult*RMSD)
float rmse = 0.0
if ts_current_len > 0
    for j = 0 to ts_current_len - 1 by 1
        rmse += math.pow(ts_src[j] - (minter + mslope * (ts_current_len - j)), 2) / ts_current_len
        rmse
dev = ts_mult * math.sqrt(rmse)

// check if channel is broken
isbroken = ts_src > ts_y2 + dev or ts_src < ts_y2 - dev

// ========== HIỂN THỊ CÁC CHỈ BÁO ==========

// Hiển thị Chỉ báo 1: Signal System
plotshape(long_signal, title='Long Entry', text='⭐\nBuy', style=shape.labelup, location=location.belowbar, color=#00ff00, textcolor=color.new(color.white, 0), size=size.auto, offset=0, editable=false)
plotshape(short_signal, title='Short Entry', text='⭐\nSell', style=shape.labeldown, location=location.abovebar, color=#ff0000, textcolor=color.new(color.white, 0), size=size.auto, offset=0, editable=false)

// Hiển thị Chỉ báo 2: Trend Following
plot(enable_trend_follow ? trail : na, 'Dynamic Line', style=plot.style_line, color=Trend == 1 ? #4caf4f00 : Trend == -1 ? #ff525200 : na)
plot(enable_trend_follow ? ex : na, 'Key Points', style=plot.style_circles, color=Trend == 1 ? #00e67700 : Trend == -1 ? #df40fb00 : na)

Zone1 = plot(enable_trend_follow and show_zones ? z1 : na, 'Zone 1', style=plot.style_line, color=color.new(#787b86, 100))
Zone2 = plot(enable_trend_follow and show_zones ? z2 : na, 'Zone 2', style=plot.style_line, color=color.new(#787b86, 100))
Zone3 = plot(enable_trend_follow and show_zones ? z3 : na, 'Zone 3', style=plot.style_line, color=color.new(#787b86, 100))
L100 = plot(enable_trend_follow and show_zones ? l100 : na, 'Base Line', style=plot.style_line, color=color.new(#787b86, 100))

fill(Zone1, Zone2, color=enable_trend_follow and show_zones ? (state == 'up' ? color.rgb(24, 40, 82, 30) : state == 'down' ? color.rgb(58, 3, 46, 55) : na) : na, transp=90)
fill(Zone2, Zone3, color=enable_trend_follow and show_zones ? (state == 'up' ? color.rgb(24, 40, 82, 30) : state == 'down' ? color.rgb(58, 3, 46, 55) : na) : na, transp=90)
fill(Zone3, L100, color=enable_trend_follow and show_zones ? (state == 'up' ? color.rgb(24, 40, 82, 30) : state == 'down' ? color.rgb(58, 3, 46, 55) : na) : na, transp=90)

// Hiển thị Chỉ báo 3: Theil-Sen Estimator
var line ts_line = na
var line ts_upper_line = na
var line ts_lower_line = na
var label ts_label = na

if enable_theilsen and barstate.islast and ts_current_len > 0
    // Delete previous lines
    if not na(ts_line)
        line.delete(ts_line)
    if not na(ts_upper_line)
        line.delete(ts_upper_line)
    if not na(ts_lower_line)
        line.delete(ts_lower_line)
    if not na(ts_label)
        label.delete(ts_label)
    
    // Create new lines
    ts_line := line.new(ts_x1, ts_y1, ts_x2, ts_y2, xloc.bar_index, extend=ts_extendln ? extend.right : extend.none, color=isbroken ? ts_colbr : mslope > 0 ? ts_colup : ts_coldw, width=ts_lw)
    
    if ts_showinterval
        ts_upper_line := line.new(ts_x1, ts_y1 + dev, ts_x2, ts_y2 + dev, xloc.bar_index, extend=ts_extendln ? extend.right : extend.none, color=isbroken ? ts_colbr : mslope > 0 ? ts_colup : ts_coldw, width=1, style=line.style_dashed)
        ts_lower_line := line.new(ts_x1, ts_y1 - dev, ts_x2, ts_y2 - dev, xloc.bar_index, extend=ts_extendln ? extend.right : extend.none, color=isbroken ? ts_colbr : mslope > 0 ? ts_colup : ts_coldw, width=1, style=line.style_dashed)
    
    if ts_showresult
        ts_label := label.new(bar_index - (ts_current_len - 1), mslope > 0 ? ts_y1 - dev : ts_y1 + dev, style=mslope > 0 ? label.style_label_up : label.style_label_down, text='Slope ' + str.tostring(truncate(mslope, 2)) + ', Intercept ' + str.tostring(truncate(minter, 2)), color=mslope > 0 ? ts_colup : ts_coldw)

// ========== MÀU NẾN ==========
// Ưu tiên: Signal System > Default
final_barcolor = color.gray
if enable_signal_system
    signal_barcolor = barcolor_signal ? #15ff00 : #ff0000
    final_barcolor := signal_barcolor

barcolor(final_barcolor)

// ========== ALERTS ==========
alertcondition(long_signal, title='Pro Signal Up', message='Pro Signal Up Entry')
alertcondition(short_signal, title='Pro Signal Down', message='Pro Signal Down Entry')

alertcondition(z1_long, title='Zone 1 Cross Down', message='Price crossed below Zone 1 in uptrend')
alertcondition(z2_long, title='Zone 2 Cross Down', message='Price crossed below Zone 2 in uptrend')
alertcondition(z3_long, title='Zone 3 Cross Down', message='Price crossed below Zone 3 in uptrend')
alertcondition(z1_short, title='Zone 1 Cross Up', message='Price crossed above Zone 1 in downtrend')
alertcondition(z2_short, title='Zone 2 Cross Up', message='Price crossed above Zone 2 in downtrend')
alertcondition(z3_short, title='Zone 3 Cross Up', message='Price crossed above Zone 3 in downtrend')

alertcondition(fixnan(z1) != fixnan(z1[1]), title='Dynamic Change', message='Dynamic Line Change')

// Theil-Sen alerts
alertcondition(enable_theilsen and isbroken and not isbroken[1], title='Theil-Sen Channel Break', message='Price is Breaking the Theil-Sen Channel')

// ========== TREND2 ==========


plotRibsw = input(title='Show Trend Ribbon', defval=true , inline = "RIBBON" , group = "Chart Features")
plotRibbonPos = input.string(title='Ribbon Position', options=['Top', 'Bottom'], defval='Bottom', group = "Chart Features")
xfixtf = input(title='MTF', defval=false , inline = "RIBBON", group = "Chart Features")
xtf = input.timeframe(title='Select MTF Ribbon', defval='D', group = "Chart Features")

xsrc = close
xprd1 = 12
xsrc2 = close
xprd2 = 26
xsmooth = 1

xPrice = ta.ema(xsrc, xsmooth)
FastMA = xfixtf ? ta.ema(request.security(syminfo.tickerid, xtf, ta.ema(xsrc, xprd1)), xsmooth) : ta.ema(xPrice, xprd1)
xPrice2 = ta.ema(xsrc2, xsmooth)
SlowMA = xfixtf ? ta.ema(request.security(syminfo.tickerid, xtf, ta.ema(xsrc2, xprd2)), xsmooth) : ta.ema(xPrice2, xprd2)
BullTribbon = FastMA > SlowMA
Tribbon = FastMA < SlowMA

// Define Color Zones
Green = BullTribbon and xPrice > FastMA
Red = Tribbon and xPrice < FastMA

// Define Buy and Sell condition
buycond = Green and Green[1] == 0
sellcond = Red and Red[1] == 0

bullTribbonish = ta.barssince(buycond) < ta.barssince(sellcond)
Tribbonish = ta.barssince(sellcond) < ta.barssince(buycond)

bColor_BullTribbonTribbon = bullTribbonish ? #00FF00 : Tribbonish ? #ff0000 : na

plotshape(plotRibsw ? plotRibbonPos == 'Top' ? close : na : na, style=shape.square, title='Buy/Sell Ribbon', location=location.top, color=bColor_BullTribbonTribbon , editable = false)
plotshape(plotRibsw ? plotRibbonPos == 'Bottom' ? close : na : na, style=shape.square, title='Buy/Sell Ribbon', location=location.bottom, color=bColor_BullTribbonTribbon , editable = false)


// ========== S/R ==========


// INPUTS
showSR = input.bool(true, 'Show S/R')
srPeriod = input.int(50, 'S/R Period', minval = 10)
showMacro = input.bool(true, 'Show Macro')
macroPeriod = input.int(200, 'Macro Period', minval = 10)

// COLORS
srUpColor = input.color(#860015, 'S/R Upper')
srDownColor = input.color(#13761e, 'S/R Lower')
macroUpColor = input.color(#d10055, 'Macro Upper')
macroDownColor = input.color(#30b2be, 'Macro Lower')

// STYLE
lineWidth = input.int(2, "Line Width", 1)
showZones = input(true, "Show Zones")

// ARRAYS
var srHighs = array.new_float()
var srLows = array.new_float()
var macroHighs = array.new_float()
var macroLows = array.new_float()
var posVolSR = array.new_float()
var negVolSR = array.new_float()
var posVolMacro = array.new_float()
var negVolMacro = array.new_float()

// VARIABLES
var float deltaVolSR = na
var float deltaVolMacro = na

// LINES
var line srUpperLine = na
var line srLowerLine = na
var line macroUpperLine = na
var line macroLowerLine = na
var line midLine = na

// ATR
atrValue = ta.atr(200) * 0.3

// CALCULATIONS
if barstate.islast and showMacro
    array.clear(macroHighs)
    array.clear(macroLows)  
    array.clear(posVolMacro)
    array.clear(negVolMacro)
    
    for i = 0 to macroPeriod - 1
        array.push(macroHighs, high[i])
        array.push(macroLows, low[i])
        if close[i] > open[i]
            array.push(posVolMacro, volume[i])
        else
            array.push(posVolMacro, 0)
        if close[i] < open[i]  
            array.push(negVolMacro, volume[i])
        else
            array.push(negVolMacro, 0)
    
    posSum = array.sum(posVolMacro)
    negSum = array.sum(negVolMacro)
    deltaVolMacro := posSum > 0 ? (negSum / posSum + 1) * 100 : 100

if barstate.islast and showSR
    array.clear(srHighs)
    array.clear(srLows)
    array.clear(posVolSR)
    array.clear(negVolSR)
    
    for i = 0 to srPeriod - 1
        array.push(srHighs, high[i])
        array.push(srLows, low[i])
        if close[i] > open[i]
            array.push(posVolSR, volume[i])
        else
            array.push(posVolSR, 0)
        if close[i] < open[i]
            array.push(negVolSR, volume[i])
        else
            array.push(negVolSR, 0)
    
    posSum = array.sum(posVolSR)
    negSum = array.sum(negVolSR)
    deltaVolSR := posSum > 0 ? (negSum / posSum + 1) * 100 : 100

// DELETE OLD LINES
line.delete(srUpperLine[1])
line.delete(srLowerLine[1])
line.delete(macroUpperLine[1])
line.delete(macroLowerLine[1])
line.delete(midLine[1])

// DRAW S/R LINES
if showSR and barstate.islast
    srHigh = array.max(srHighs)
    srLow = array.min(srLows)
    midLevel = (srHigh + srLow) / 2
    
    srUpperLine := line.new(bar_index - srPeriod, srHigh, bar_index + 50, srHigh, color = srUpColor, width = lineWidth)
    srLowerLine := line.new(bar_index - srPeriod, srLow, bar_index + 50, srLow, color = srDownColor, width = lineWidth)
    midLine := line.new(bar_index - srPeriod, midLevel, bar_index + 50, midLevel, color = color.gray, style = line.style_dashed)
    
    if showZones
        upperZone1 = line.new(bar_index - srPeriod, srHigh + atrValue, bar_index + 50, srHigh + atrValue, color = na)
        upperZone2 = line.new(bar_index - srPeriod, srHigh - atrValue, bar_index + 50, srHigh - atrValue, color = na)
        lowerZone1 = line.new(bar_index - srPeriod, srLow + atrValue, bar_index + 50, srLow + atrValue, color = na)
        lowerZone2 = line.new(bar_index - srPeriod, srLow - atrValue, bar_index + 50, srLow - atrValue, color = na)
        linefill.new(upperZone1, upperZone2, color.new(srUpColor, 85))
        linefill.new(lowerZone1, lowerZone2, color.new(srDownColor, 85))

// DRAW MACRO LINES
if showMacro and barstate.islast
    macroHigh = array.max(macroHighs)
    macroLow = array.min(macroLows)
    
    macroUpperLine := line.new(bar_index - macroPeriod, macroHigh, bar_index + 70, macroHigh, color = macroUpColor, width = lineWidth + 1)
    macroLowerLine := line.new(bar_index - macroPeriod, macroLow, bar_index + 70, macroLow, color = macroDownColor, width = lineWidth + 1)
    
    if showZones
        macroUpperZone1 = line.new(bar_index - macroPeriod, macroHigh + atrValue * 1.5, bar_index + 70, macroHigh + atrValue * 1.5, color = na)
        macroUpperZone2 = line.new(bar_index - macroPeriod, macroHigh - atrValue * 1.5, bar_index + 70, macroHigh - atrValue * 1.5, color = na)
        macroLowerZone1 = line.new(bar_index - macroPeriod, macroLow + atrValue * 1.5, bar_index + 70, macroLow + atrValue * 1.5, color = na)
        macroLowerZone2 = line.new(bar_index - macroPeriod, macroLow - atrValue * 1.5, bar_index + 70, macroLow - atrValue * 1.5, color = na)
        linefill.new(macroUpperZone1, macroUpperZone2, color.new(macroUpColor, 65))
        linefill.new(macroLowerZone1, macroLowerZone2, color.new(macroDownColor, 65))

// LABELS
var label srPremiumLabel = na
var label srDiscountLabel = na
var label srDeltaLabel = na
var label macroPremiumLabel = na
var label macroDiscountLabel = na

label.delete(srPremiumLabel[1])
label.delete(srDiscountLabel[1])
label.delete(srDeltaLabel[1])
label.delete(macroPremiumLabel[1])
label.delete(macroDiscountLabel[1])

if showSR and barstate.islast
    srHigh = array.max(srHighs)
    srLow = array.min(srLows)
    midLevel = (srHigh + srLow) / 2
    
    srPremiumLabel := label.new(bar_index + 55, srHigh, "PREMIUM: " + str.tostring(array.sum(negVolSR), format.volume), color = srUpColor, textcolor = color.white, style = label.style_label_left, size = size.small)
    srDiscountLabel := label.new(bar_index + 55, srLow, "DISCOUNT: " + str.tostring(array.sum(posVolSR), format.volume), color = srDownColor, textcolor = color.white, style = label.style_label_left, size = size.small)
    srDeltaLabel := label.new(bar_index + 55, midLevel, "Delta Volume\n" + str.tostring(deltaVolSR, format.percent), color = deltaVolSR > 0 ? srDownColor : srUpColor, textcolor = color.white, style = label.style_label_left, size = size.normal)

if showMacro and barstate.islast
    macroHigh = array.max(macroHighs)
    macroLow = array.min(macroLows)
    
    macroPremiumLabel := label.new(bar_index + 75, macroHigh, str.tostring(array.sum(negVolMacro), format.volume), color = macroUpColor, textcolor = color.white, style = label.style_label_right, size = size.small)
    macroDiscountLabel := label.new(bar_index + 75, macroLow, str.tostring(array.sum(posVolMacro), format.volume), color = macroDownColor, textcolor = color.white, style = label.style_label_right, size = size.small)

//==================== CLOUD 2 ====================


// Cho phép bật/tắt Cirrus Cloud
CirrusCloud = input(true, 'Cirrus Cloud', group='TREND FEATURES')

// Các thông số làm mượt
x1 = 22
x2 = 9
x3 = 15
x4 = 5

// Hàm làm mượt biến động giá
smoothrngX1(x, t, m) =>
    wper  = t * 2 - 1
    avrng = ta.ema(math.abs(x - x[1]), t)
    ta.ema(avrng, wper) * m

// Tính toán độ mượt
smrngx1x  = smoothrngX1(close, x1, x2)
smrngx1x2 = smoothrngX1(close, x3, x4)

// Hàm lọc biên độ dao động
rngfiltx1x1(x, r) =>
    var float filt = x
    filt := x > nz(filt[1]) ? (x - r < nz(filt[1]) ? nz(filt[1]) : x - r)
          : (x + r > nz(filt[1]) ? nz(filt[1]) : x + r)
    filt

// Tạo 2 đường biên cho vùng đám mây
filtx1  = rngfiltx1x1(close, smrngx1x)
filtx12 = rngfiltx1x1(close, smrngx1x2)

// Màu sắc vùng mây
cloudColor = filtx1 > filtx12 ? color.rgb(254, 0, 0, 86) : color.rgb(21, 255, 0, 86)
lineColor  = color.rgb(0, 187, 212, 100)

// Vẽ vùng Cirrus Cloud nếu bật
plot1 = plot(CirrusCloud ? filtx1 : na, color=lineColor, linewidth=1, title='Trend Tracer 1')
plot2 = plot(CirrusCloud ? filtx12 : na, color=lineColor, linewidth=1, title='Trend Tracer 2')
fill(plot1, plot2, color=cloudColor)



//==================== TREND 2 ====================\\


G_SCRIPT01   = '■ ' + 'SAIYAN OCC'
//#region ———— <↓↓↓ G_SCRIPT01 ↓↓↓> {

// === INPUTS ===
res5                       = input.timeframe('15',  'TIMEFRAME', group ="NON REPAINT")
useRes                    = input(true,            'Use Alternate Signals')
intRes                    = input(10,               'Multiplier for Alernate Signals')
basisType                 = input.string('ALMA',   'MA Type: ', options=['TEMA', 'HullMA', 'ALMA'])
basisLen                  = input.int(50,           'MA Period', minval=1)
offsetSigma               = input.int(5,           'Offset for LSMA / Sigma for ALMA', minval=0)
offsetALMA                = input.float(2,      'Offset for ALMA', minval=0, step=0.01)
delayOffset               = input.int(0,           'Delay Open/Close MA', minval=0, step=1,
                  tooltip = 'Forces Non-Repainting')
tradeType                 = input.string('BOTH',   'What trades should be taken : ',
                  options = ['LONG', 'SHORT', 'BOTH', 'NONE'])

// RSI Settings
rsi_period               = input.int(28, 'RSI Period', minval=1, group="RSI Settings")
rsi_overbought           = input.int(65, 'RSI Overbought Level', minval=50, maxval=90, group="RSI Settings")
rsi_oversold             = input.int(35, 'RSI Oversold Level', minval=10, maxval=50, group="RSI Settings")
ema_period               = input.int(144, 'EMA Period', minval=1, group="RSI Settings")

// Label Display Settings
show_basic_signals       = input.bool(true, 'Show Basic Signals', group="Display")
show_strong_signals      = input.bool(true, 'Show Strong Signals', group="Display")
show_rsi_confluence      = input.bool(false, 'Show RSI Confluence Only', group="Display")

//=== /INPUTS ===
h                         = input(false,           'Signals for Heikin Ashi Candles')
//INDICATOR SETTINGS
swing_length              = input.int(10,          'Swing High/Low Length', group = 'Settings', minval = 1, maxval = 50)
history_of_demand_to_keep = input.int(20,          'History To Keep', minval = 5, maxval = 50)
box_width                 = input.float(2.5,       'Supply/Demand Box Width', group = 'Settings', minval = 1, maxval = 10, step = 0.5)

//END SETTINGS

//      FUNCTION TO ADD NEW AND REMOVE LAST IN ARRAY
f_array_add_pop(array, new_value_to_add) =>
    array.unshift(array, new_value_to_add)
    array.pop(array)

//      FUNCTION SWING H & L LABELS
f_sh_sl_labels(array, swing_type) =>
    var string label_text = na
    if swing_type == 1
        if array.get(array, 0) >= array.get(array, 1)
            label_text := 'HH'
        else
            label_text := 'LH'
    else if swing_type == -1
        if array.get(array, 0) >= array.get(array, 1)
            label_text := 'HL'
        else
            label_text := 'LL'

//      FUNCTION MAKE SURE SUPPLY ISNT OVERLAPPING
f_check_overlapping(new_poi, box_array, atrValue) =>
    atr_threshold = atrValue * 2
    okay_to_draw = true
    for i = 0 to array.size(box_array) - 1
        top = box.get_top(array.get(box_array, i))
        bottom = box.get_bottom(array.get(box_array, i))
        poi = (top + bottom) / 2
        upper_boundary = poi + atr_threshold
        lower_boundary = poi - atr_threshold
        if new_poi >= lower_boundary and new_poi <= upper_boundary
            okay_to_draw := false
            break
        else 
            okay_to_draw := true
    okay_to_draw

//      FUNCTION TO DRAW SUPPLY OR DEMAND ZONE
f_supply_demand(value_array, bn_array, box_array, label_array, box_type, atrValue) =>
    atr_buffer = atrValue * (box_width / 10)
    box_left   = array.get(bn_array, 0)
    box_right  = bar_index
    var float box_top = 0.00
    var float box_bottom = 0.00
    var float poi = 0.00
    if box_type == 1
        box_top := array.get(value_array, 0)
        box_bottom := box_top - atr_buffer
        poi := (box_top + box_bottom) / 2
    else if box_type == -1
        box_bottom := array.get(value_array, 0)
        box_top := box_bottom + atr_buffer
        poi := (box_top + box_bottom) / 2
    okay_to_draw = f_check_overlapping(poi, box_array, atrValue)

//      FUNCTION TO CHANGE SUPPLY/DEMAND TO A BOS IF BROKEN
f_sd_to_bos(box_array, bos_array, label_array, zone_type) =>
    if zone_type == 1
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_top(array.get(box_array,i))
            if close >= level_to_break
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))
    if zone_type == -1
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_bottom(array.get(box_array,i))
            if close <= level_to_break
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))

//      FUNCTION MANAGE CURRENT BOXES BY CHANGING ENDPOINT
f_extend_box_endpoint(box_array) =>
    for i = 0 to array.size(box_array) - 1
        box.set_right(array.get(box_array, i), bar_index + 100)

//
stratRes = timeframe.ismonthly  ? str.tostring(timeframe.multiplier * intRes, '###M') :
           timeframe.isweekly   ? str.tostring(timeframe.multiplier * intRes, '###W') :
           timeframe.isdaily    ? str.tostring(timeframe.multiplier * intRes, '###D') :
           timeframe.isintraday ? str.tostring(timeframe.multiplier * intRes, '####') :
           '60'
src5      = h ? request.security(ticker.heikinashi(syminfo.tickerid),
           timeframe.period, close, lookahead = barmerge.lookahead_off) : close

//      CALCULATE ATR 
atrValue5 = ta.atr(50)

//      CALCULATE SWING HIGHS & SWING LOWS
swing_high = ta.pivothigh(high, swing_length, swing_length)
swing_low  = ta.pivotlow(low,   swing_length, swing_length)

//      ARRAYS FOR SWING H/L & BN 
var swing_high_values  = array.new_float(5,0.00)
var swing_low_values   = array.new_float(5,0.00)
var swing_high_bns     = array.new_int(5,0)
var swing_low_bns      = array.new_int(5,0)

//      ARRAYS FOR SUPPLY / DEMAND
var current_supply_box = array.new_box(history_of_demand_to_keep, na)
var current_demand_box = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR SUPPLY / DEMAND POI LABELS
var current_supply_poi = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR BOS
var supply_bos         = array.new_box(5, na)
var demand_bos         = array.new_box(5, na)

//END CALCULATIONS

//      NEW SWING HIGH
if not na(swing_high)
    //MANAGE SWING HIGH VALUES
    f_array_add_pop(swing_high_values, swing_high)
    f_array_add_pop(swing_high_bns, bar_index[swing_length])
    f_sh_sl_labels(swing_high_values, 1)
    f_supply_demand(swing_high_values, swing_high_bns, current_supply_box, current_supply_poi, 1, atrValue)

//      NEW SWING LOW
else if not na(swing_low)
    //MANAGE SWING LOW VALUES
    f_array_add_pop(swing_low_values, swing_low)
    f_array_add_pop(swing_low_bns, bar_index[swing_length])
    f_sh_sl_labels(swing_low_values, -1)
    f_supply_demand(swing_low_values, swing_low_bns, current_demand_box, current_demand_poi, -1, atrValue)

f_sd_to_bos(current_supply_box, supply_bos, current_supply_poi, 1)
f_sd_to_bos(current_demand_box, demand_bos, current_demand_poi, -1)

f_extend_box_endpoint(current_supply_box)
f_extend_box_endpoint(current_demand_box)

channelBal     = input.bool(false, "Channel Balance", group = "CHART")

// Create non-repainting security function
rp_security(_symbol, _res, _src) =>
    request.security(_symbol, _res, _src[barstate.isrealtime ? 1 : 0])

htfHigh = rp_security(syminfo.tickerid, res, high)
htfLow  = rp_security(syminfo.tickerid, res, low)

// Get user input
enableSR   = input(false          , "SR On/Off", group="SR")
colorSup   = input(#00000000        , "Support Color", group="SR")
colorRes   = input(#00000000        , "Resistance Color", group="SR")
strengthSR = input.int(2          , "S/R Strength", 1, group="SR")
lineStyle  = input.string("Dotted", "Line Style", ["Solid", "Dotted", "Dashed"], group="SR")
lineWidth5  = input.int(2          , "S/R Line Width", 1, group="SR")
useZones   = input(true           , "Zones On/Off", group="SR")
useHLZones = input(true           , "High Low Zones On/Off", group="SR")
zoneWidth  = input.int(2          , "Zone Width %", 0,
   tooltip = "it's calculated using % of the distance between highest/lowest in last 300 bars", group="SR")
expandSR   = input(true           , "Expand SR")

// security wrapper for repeat calls
reso(exp, use, res) =>
    security_1 = request.security(syminfo.tickerid, res, exp, gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
    use ? security_1 : exp

// === BASE FUNCTIONS ===
// Returns MA input selection variant, default to SMA if blank or typo.
variant(type, src, len, offSig, offALMA) =>
    v1    = ta.sma(src, len)  // Simple
    v2    = ta.ema(src, len)  // Exponential
    v3    = 2 * v2 - ta.ema(v2, len)  // Double Exponential
    v4    = 3 * (v2 - ta.ema(v2, len)) + ta.ema(ta.ema(v2, len), len)  // Triple Exponential
    v5    = ta.wma(src, len)  // Weighted
    v6    = ta.vwma(src, len)  // Volume Weighted
    v7    = 0.0
    sma_1 = ta.sma(src, len)  // Smoothed
    v7   := na(v7[1]) ? sma_1 : (v7[1] * (len - 1) + src) / len
    v8    = ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt(len)))  // Hull
    v9    = ta.linreg(src, len, offSig)  // Least Squares
    v10   = ta.alma(src, len, offALMA, offSig)  // Arnaud Legoux
    v11   = ta.sma(v1, len)  // Triangular (extreme smooth)
    // SuperSmoother filter
    //   2013  John F. Ehlers
    a1    = math.exp(-1.414 * 3.14159 / len)
    b1    = 2 * a1 * math.cos(1.414 * 3.14159 / len)
    c2    = b1
    c3    = -a1 * a1
    c1    = 1 - c2 - c3
    v12   = 0.0
    v12  := c1 * (src + nz(src[1])) / 2 + c2 * nz(v12[1]) + c3 * nz(v12[2])
    type == 'EMA' ? v2 : type == 'DEMA' ? v3 : type == 'TEMA' ? v4 : type == 'WMA' ? v5 : type == 'VWMA' ? v6 : type == 'SMMA' ? v7 : type == 'HullMA' ? v8 : type == 'LSMA' ? v9 : type == 'ALMA' ? v10 : type == 'TMA' ? v11 : type == 'SSMA' ? v12 : v1

// === SERIES SETUP ===
closeSeries = variant(basisType, close[delayOffset], basisLen, offsetSigma, offsetALMA)
openSeries  = variant(basisType, open[delayOffset],  basisLen, offsetSigma, offsetALMA)

// Get Alternate resolution Series if selected.
closeSeriesAlt = reso(closeSeries, useRes, stratRes)
openSeriesAlt  = reso(openSeries, useRes, stratRes)

//<triggers>
leTrigger    = ta.crossover (closeSeriesAlt, openSeriesAlt)
seTrigger    = ta.crossunder(closeSeriesAlt, openSeriesAlt)

// RSI conditions for additional confluence - FIXED LOGIC
rsi       = ta.rsi(close, rsi_period)
rsi_ema   = ta.ema(rsi, 10)
ema       = ta.ema(close, ema_period)

// Enhanced RSI conditions
rsiOb     = rsi > rsi_overbought and rsi > rsi_ema
rsiOs     = rsi < rsi_oversold and rsi < rsi_ema

// Price vs EMA conditions
price_above_ema = close > ema
price_below_ema = close < ema

// Combined confluence conditions - SIMPLIFIED
rsi_bullish = rsiOs or (rsi < 50 and price_above_ema)
rsi_bearish = rsiOb or (rsi > 50 and price_below_ema)

// Enhanced signals with RSI confluence
strong_buy = leTrigger and rsi_bullish
strong_sell = seTrigger and rsi_bearish

// Conditional display based on user settings
show_le = show_basic_signals and (show_rsi_confluence ? strong_buy : leTrigger)
show_se = show_basic_signals and (show_rsi_confluence ? strong_sell : seTrigger)

// Signal Shapes - Basic entry signals
plotshape(show_le, title='Long Signal', text='△', textcolor=color.white, 
          color=#008000, style=shape.labelup, size=size.tiny, location=location.belowbar)
plotshape(show_se, title='Short Signal', text='▽', textcolor=color.white, 
          color=#ff0034, style=shape.labeldown, size=size.tiny, location=location.abovebar)

// Strong signals - MORE VISIBLE
plotshape(show_strong_signals and strong_buy, title='Strong Buy', text='STRONG', textcolor=color.white, 
          color=color.lime, style=shape.labelup, size=size.tiny, location=location.belowbar)
plotshape(show_strong_signals and strong_sell, title='Strong Sell', text='STRONG', textcolor=color.white, 
          color=color.maroon, style=shape.labeldown, size=size.tiny, location=location.abovebar)

// Debug plots for RSI values (optional - can be viewed in Data Window)
plot(rsi, title="RSI", display=display.data_window, color=color.blue)
plot(rsi_ema, title="RSI EMA", display=display.data_window, color=color.orange)

// Alerts
alertcondition(leTrigger, title="Long Entry Alert", message="Long Signal")
alertcondition(seTrigger, title="Short Entry Alert", message="Short Signal") 
alertcondition(strong_buy, title="Strong Buy Alert", message="Strong Buy Signal")
alertcondition(strong_sell, title="Strong Sell Alert", message="Strong Sell Signal")

// ========== RSI ==========
const bool DEBUG = false
const int maxDistanceToLastBar = 5000
const int labelCooldown = 8
const int KDELimit = 300

rsiLengthInput = input.int(14, minval = 1, title="RSI Length", group="RSI Settings")
rsiSourceInput = input.source(close, "Source", group="RSI Settings")

highPivotLen = input.int(21,  "High Pivot Length", minval = 1, group = "Pivots", display = display.none)
lowPivotLen = input.int(21, "Low Pivot Length", minval = 1, group = "Pivots", display = display.none)
realPivotLabels = DEBUG ? input.bool(false, "[DBG] Real Pivot Labels", group = "Pivots") : false
kdePivotLabels = DEBUG ? input.bool(false, "[DBG] KDE Pivot Labels", group = "Pivots") : false

activationThresholdStr = input.string("Medium", "Activation Threshold", options = ["High", "Medium", "Low"], group = "KDE", tooltip = "Determines the amount of arrows shown. Higher options will result in more arrows being rendered.")
string KDEKernel = input.string("Gaussian", "Kernel", options=['Uniform', 'Gaussian', 'Sigmoid'], group = "KDE", tooltip = "The kernel function for KDE calculation. Gaussian is a commonly used kernel and is based on normal distribution.")
float KDEBandwidth = input.float(2.71828, "Bandwidth", group = "KDE", tooltip = "This setting sets the smoothness of the KDE function output.")
int KDEStep = input.int(100, "Nº Bins", minval = 1, group = "KDE", tooltip = "The number of elements the KDE Probability array will have. Higher settings will result in greater precision.")
activationThreshold = DEBUG ? input.float(0.25, "[DBG] Activation Threshold", group = "KDE") : 0.25
if not DEBUG
    activationThreshold := (activationThresholdStr == "High" ? 0.4 : activationThresholdStr == "Medium" ? 0.25 : 0.15)
probMode = DEBUG ? input.string("Sum", '[DBG] Probability Mode', options = ["Sum", "Nearest"], group = "KDE") : "Sum"
minPadding = DEBUG ? input.bool(false, '[DBG] KDE Min Padding', group = "KDE") : false

bearishColor = input.color(#ff0000, "High Pivots", group = "Style", inline = "col", display = display.none)
neutralColor = input.color(color.gray, "Neutral", group = "Style", inline = "col", display = display.none)
bullishColor = input.color(#00FF00, "Low Pivots", group = "Style", inline = "col", display = display.none)
textColor = input.color(color.white, 'Text', group = 'Style', inline = "col", display = display.none)
RSILabelsEnabled = input.bool(true, "RSI Labels", group = "Style")
KDELabelsEnabled = input.bool(true, "KDE Labels", group = "Style")

// THAY ĐỔI TÊN BIẾN RSI ĐỂ TRÁNH XUNG ĐỘT
rsi_kernel_optimized = ta.rsi(rsiSourceInput, rsiLengthInput)

//#region KDE
gaussian (float distance, float bandwidth = 1.0) => 1.0 / math.sqrt(2.0 * math.pi) * math.pow(math.e, -0.5 * math.pow(distance / bandwidth, 2.0))
uniform (float distance, float bandwidth = 1.0) => (math.abs(distance) > bandwidth) ? 0.0 : 0.5
sigmoid (float distance, float bandwidth = 1.0) => 2.0 / math.pi * (1.0 / (math.pow(math.e, (distance / bandwidth)) + math.pow(math.e, -(distance / bandwidth))))

kde (array<float> arr, string kernel, float bandwidth, int steps) =>
    arrSize = arr.size()
    arrRange = arr.range()
    arrMin = arr.min() - (minPadding ? (arrRange / 2.0) : 0)
    stepCount = arrRange / steps
    
    densityRange = array.new<float>(steps * 2)
    for i = 0 to (steps * 2) - 1
        densityRange.set(i, arrMin + i * stepCount)
    
    xArr = array.new<float>()
    yArr = array.new<float>()
    for i = 0 to densityRange.size() - 1
        float temp = 0
        for j = 0 to arr.size() - 1
            switch KDEKernel
                "Gaussian" => temp += gaussian(densityRange.get(i) - arr.get(j), 1.0 / bandwidth)
                "Uniform" => temp += uniform(densityRange.get(i) - arr.get(j), 1.0 / bandwidth)
                "Sigmoid" => temp += sigmoid(densityRange.get(i) - arr.get(j), 1.0 / bandwidth)
        
        xArr.push(densityRange.get(i))
        yArr.push(1.0 / arrSize * temp)
    [xArr, yArr]
//#endregion

//#region Pivots

prefixSum (array<float> arr, int l, int r) =>
    arr.get(r) - (l == 0 ? 0 : arr.get(l - 1))

float MidKDEHigh = na
float MidKDELow = na

var array<float> KDEHighX = na
var array<float> KDEHighY = na
var array<float> KDEHighYSum = array.new<float>()

var array<float> KDELowX = na
var array<float> KDELowY = na
var array<float> KDELowYSum = array.new<float>()

highPivot = ta.pivothigh(highPivotLen, highPivotLen)
lowPivot = ta.pivotlow(lowPivotLen, lowPivotLen)

var highPivotRSIs = array.new<float>()
var lowPivotRSIs = array.new<float>()

if not na(highPivot)
    if highPivotRSIs.size() > KDELimit
        highPivotRSIs.remove(0)
    highPivotRSIs.push(rsi_kernel_optimized[highPivotLen])

    [KDEHighX1, KDEHighY1] = kde(highPivotRSIs, KDEKernel, KDEBandwidth, KDEStep)
    KDEHighX := KDEHighX1
    KDEHighY := KDEHighY1
    
    KDEHighYSum.clear()
    temp = 0.0
    for i = 0 to KDEHighY.size() - 1
        temp += KDEHighY.get(i)
        KDEHighYSum.push(temp)

    MidKDEHigh := array.get(KDEHighX, array.indexof(KDEHighY, array.max(KDEHighY)))

if not na(lowPivot)
    if lowPivotRSIs.size() > KDELimit
        lowPivotRSIs.remove(0)
    lowPivotRSIs.push(rsi_kernel_optimized[lowPivotLen])

    [KDELowX1, KDELowY1] = kde(lowPivotRSIs, KDEKernel, KDEBandwidth, KDEStep)
    KDELowX := KDELowX1
    KDELowY := KDELowY1

    KDELowYSum.clear()
    temp = 0.0
    for i = 0 to KDELowY.size() - 1
        temp += KDELowY.get(i)
        KDELowYSum.push(temp)

    MidKDELow := array.get(KDELowX, array.indexof(KDELowY, array.max(KDELowY)))
//#endregion

//#region KDE Optimization
f_lin_interpolate(float x0, float x1, float y0, float y1, float x) =>
    y0 + (x - x0) * (y1 - y0) / (x1 - x0)

float lowProb = na
float maxLowProb = na
float highProb = na
float maxHighProb = na

if last_bar_index - maxDistanceToLastBar < bar_index
    if highPivotRSIs.size() > 0
        highXIndexL = array.binary_search_leftmost(KDEHighX, rsi_kernel_optimized)
        highXIndexR = math.min(array.binary_search_rightmost(KDEHighX, rsi_kernel_optimized), KDEHighX.size() - 1)
        nearestIndex = (math.abs(rsi_kernel_optimized - KDEHighX.get(highXIndexL)) < math.abs(rsi_kernel_optimized - KDEHighX.get(highXIndexR))) ? highXIndexL : highXIndexR
        if probMode == "Nearest"
            highProb := KDEHighY.get(nearestIndex)
            maxHighProb := array.max(KDEHighY)
        else if probMode == "Sum"
            highProb := prefixSum(KDEHighYSum, 0, nearestIndex)
    
    if lowPivotRSIs.size() > 0
        lowXIndexL = array.binary_search_leftmost(KDELowX, rsi_kernel_optimized)
        lowXIndexR = math.min(array.binary_search_rightmost(KDELowX, rsi_kernel_optimized), KDELowX.size() - 1)
        nearestIndex = (math.abs(rsi_kernel_optimized - KDELowX.get(lowXIndexL)) < math.abs(rsi_kernel_optimized - KDELowX.get(lowXIndexR))) ? lowXIndexL : lowXIndexR
        if probMode == "Nearest"
            lowProb := KDELowY.get(nearestIndex)
            maxLowProb := array.max(KDELowY)
        else if probMode == "Sum"
            lowProb := prefixSum(KDELowYSum, nearestIndex, KDELowYSum.size() - 1)

        if DEBUG and barstate.islastconfirmedhistory
            for i = 0 to KDELowX.size() - 1
                curX = KDELowX.get(i)
                curY = KDELowY.get(i)
                log.info(str.tostring(curX) + " = " + str.tostring(curY))
            log.info("High Y Sum " + str.tostring(KDEHighY.sum()))

diffToHighKDE = math.abs(rsi_kernel_optimized - MidKDEHigh)
diffToLowKDE = math.abs(rsi_kernel_optimized - MidKDELow)
//#endregion

//#region Draw Pivots
color curColor = na
if (not na(KDELowY)) and (not na(KDEHighY))
    if probMode == "Nearest"
        if math.abs(lowProb - maxLowProb) < activationThreshold / 50.0
            curColor := bullishColor
        if math.abs(highProb - maxHighProb) < activationThreshold / 50.0
            curColor := bearishColor
    else if probMode == "Sum"
        if lowProb > KDELowY.sum() * (1.0 - activationThreshold)
            curColor := bullishColor
        else if highProb > KDEHighY.sum() * (1.0 - activationThreshold)
            curColor := bearishColor
//barcolor(curColor)

atr = ta.atr(50)

plotarrow((na(curColor) and curColor[1] == bullishColor and barstate.isconfirmed) ? 1 : na, "Possible Bullish Pivot", bullishColor, bullishColor, minheight = 20, maxheight = 20)
plotarrow((na(curColor) and curColor[1] == bearishColor and barstate.isconfirmed) ? -1 : na, "Possible Bearish Pivot", bearishColor, bearishColor, minheight = 20, maxheight = 20)

alertcondition(na(curColor) and curColor[1] == bullishColor and barstate.isconfirmed, "Possible Bullish Pivot")
alertcondition(na(curColor) and curColor[1] == bearishColor and barstate.isconfirmed, "Possible Bearish Pivot")

if KDELabelsEnabled or RSILabelsEnabled
    var lastBullishLabel = 0
    if (na(curColor) and curColor[1] == bullishColor and barstate.isconfirmed) and (bar_index - lastBullishLabel) > labelCooldown
        lastBullishLabel := bar_index
        txt = ""
        if RSILabelsEnabled and KDELabelsEnabled
            txt := "RSI | " + str.tostring(rsi_kernel_optimized, "#") + " | " + str.tostring(lowProb * 100, "#.##") + "%"
        else if RSILabelsEnabled
            txt := "RSI | " + str.tostring(rsi_kernel_optimized, "#")
        else
            txt := str.tostring(rsi_kernel_optimized, "#") + "%"
        label.new(bar_index, low, txt, yloc = yloc.belowbar, color = na, style = label.style_label_up, textcolor = textColor, size = size.small, force_overlay = true)
        
    var lastBearishLabel = 0
    if (na(curColor) and curColor[1] == bearishColor and barstate.isconfirmed) and (bar_index - lastBearishLabel) > labelCooldown
        lastBearishLabel := bar_index
        txt = ""
        if RSILabelsEnabled and KDELabelsEnabled
            txt := "RSI | " + str.tostring(rsi_kernel_optimized, "#") + " | " + str.tostring(highProb * 100, "#.##") + "%"
        else if RSILabelsEnabled
            txt := "RSI | " + str.tostring(rsi_kernel_optimized, "#")
        else
            txt := str.tostring(rsi_kernel_optimized, "#") + "%"
        label.new(bar_index, low, txt, yloc = yloc.abovebar, color = na, style = label.style_label_down, textcolor = textColor, size = size.small, force_overlay = true)

if kdePivotLabels
    txt = str.tostring(rsi_kernel_optimized, "#.##") + "\nHP -> " + str.tostring(highProb, "#.##") + "\nLP -> " + str.tostring(lowProb, "#.##") + "\n\nMHP -> " + str.tostring(maxHighProb, "#.##") + "\nMLP -> " + str.tostring(maxLowProb, "#.##")
    if math.abs(lowProb - maxLowProb) < activationThreshold
        label.new(bar_index, high, txt, yloc = yloc.belowbar, color = textColor, style = label.style_label_up, textcolor = color.black, force_overlay = true)
    if math.abs(highProb - maxHighProb) < activationThreshold
        label.new(bar_index, high, txt, yloc = yloc.abovebar, color = textColor, style = label.style_label_down, textcolor = color.black, force_overlay = true)

if realPivotLabels
    if not na(highPivot)
        txt = str.tostring(rsi_kernel_optimized[highPivotLen], "#.##") + "\nHP -> " + str.tostring(highProb[highPivotLen], "#.##") + "\nLP -> " + str.tostring(lowProb[highPivotLen], "#.##") + "\n\nMHP -> " + str.tostring(maxHighProb[highPivotLen], "#.##") + "\nMLP -> " + str.tostring(maxLowProb[highPivotLen], "#.##")
        label.new(bar_index - highPivotLen, high, txt, yloc = yloc.abovebar, color = textColor, style = label.style_label_down, textcolor = color.black, force_overlay = true)
    if not na(lowPivot)
        txt = str.tostring(rsi_kernel_optimized[lowPivotLen], "#.##") + "\nHP -> " + str.tostring(highProb[lowPivotLen], "#.##") + "\nLP -> " + str.tostring(lowProb[lowPivotLen], "#.##") + "\n\nMHP -> " + str.tostring(maxHighProb[lowPivotLen], "#.##") + "\nMLP -> " + str.tostring(maxLowProb[lowPivotLen], "#.##")
        label.new(bar_index - lowPivotLen, high, txt, yloc = yloc.belowbar, color = textColor, style = label.style_label_up, textcolor = color.black, force_overlay = true)
//#endregion



//@version=5



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* DASHBOARD 1 SETTINGS (XEM BANG 1) *//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//* TABLE SETTINGS *//
show_dashboard1 = input(true, title = "Show Dashboard 1 (Xem Bang)", group = 'Dashboard 1 - Xem Bang')
show_header_d1 = input(false, title = "Show header?", group = 'Dashboard 1 - Table Settings')
show_ema_value_d1 = input(false, title = "Show EMA value?", group = 'Dashboard 1 - Table Settings')
show_pressure_gauge_d1 = input(true, title = "Show Pressure Gauge?", group = 'Dashboard 1 - Table Settings')
text_size_d1 = input.session('Normal', "Size", options = ["Tiny", "Small", "Normal", "Large"], group = 'Dashboard 1 - Table Settings')
text_color_d1 = input.color(defval = color.white, title = "Text colour", group = 'Dashboard 1 - Table Settings')
table_color_d1 = input.color(defval = color.gray, title = "Border colour", group = 'Dashboard 1 - Table Settings')

uptrend_indicator_d1 = input("🟢", title = "Uptrend indicator", group = 'Dashboard 1 - Table Settings')
downtrend_indicator_d1 = input("🔴", title = "Downtrend indicator", group = 'Dashboard 1 - Table Settings')
neutraltrend_indicator_d1 = input("⚫️", title = "Neutraltrend indicator", group = 'Dashboard 1 - Table Settings')

// COLOR SETTINGS FOR EACH COLUMN - Dashboard 1
header_bg_color_d1 = input.color(#2e2e30, title = "Header background colour", group = 'Dashboard 1 - Color Settings')

// Timeframe column colors
tf_bg_color_d1 = input.color(color.rgb(50, 50, 50, 75), title = "Timeframe column background colour", group = 'Dashboard 1 - Color Settings')

// Trend column colors
trend_uptrend_bg_color_d1 = input.color(#0a5204, title = "Trend column - Uptrend background colour", group = 'Dashboard 1 - Color Settings')
trend_downtrend_bg_color_d1 = input.color(#d20040, title = "Trend column - Downtrend background colour", group = 'Dashboard 1 - Color Settings')
trend_neutraltrend_bg_color_d1 = input.color(#999999, title = "Trend column - Neutraltrend background colour", group = 'Dashboard 1 - Color Settings')

// EMA column colors (if shown)
ema_uptrend_bg_color_d1 = input.color(color.rgb(76, 175, 80, 75), title = "EMA column - Uptrend background colour", group = 'Dashboard 1 - Color Settings')
ema_downtrend_bg_color_d1 = input.color(color.rgb(255, 82, 82, 75), title = "EMA column - Downtrend background colour", group = 'Dashboard 1 - Color Settings')
ema_neutraltrend_bg_color_d1 = input.color(color.rgb(120, 123, 134, 75), title = "EMA column - Neutraltrend background colour", group = 'Dashboard 1 - Color Settings')

// Pressure column colors
pressure_uptrend_bg_color_d1 = input.color(#0096ff, title = "Pressure column - Uptrend background colour", group = 'Dashboard 1 - Color Settings')
pressure_downtrend_bg_color_d1 = input.color(#ff0000, title = "Pressure column - Downtrend background colour", group = 'Dashboard 1 - Color Settings')
pressure_neutraltrend_bg_color_d1 = input.color(#999999, title = "Pressure column - Neutraltrend background colour", group = 'Dashboard 1 - Color Settings')

//* EMA SETTINGS *//
trend_identification_approach_d1 = input.session("Direction of a single EMA", "Trend identification approach", ["Direction of a single EMA", "Comparison of the two EMAs"], group = 'Dashboard 1 - EMA Settings')
ema1_length_d1 = input.int(title = "EMA length", defval = 50, minval = 1, maxval = 800, group = 'Dashboard 1 - EMA Settings')
ema2_length_d1 = input.int(title = "Additional EMA length", defval = 200, minval = 1, maxval = 800, tooltip = 'Note that the single EMA trend identification approach ignores this value.', group = 'Dashboard 1 - EMA Settings')
catch_flat_d1 = input(false, title = "Try to catch flat?", group = 'Dashboard 1 - EMA Settings')

//* PRESSURE GAUGE SETTINGS *//
sell_color_d1 = input.color(color.red, title = 'Sell Color', group = 'Dashboard 1 - Pressure Gauge Settings')
buy_color_d1 = input.color(color.green, title = 'Buy Color', group = 'Dashboard 1 - Pressure Gauge Settings')
lookback_pressure_d1 = input.int(50, title = 'Lookback Period', minval = 10, maxval = 1000, step = 10, group = 'Dashboard 1 - Pressure Gauge Settings')

//* TIMEFRAME SETTINGS *//
tf1_d1 = input.timeframe('1', title = 'Timeframe 1', group = 'Dashboard 1 - Timeframe Settings')
tf2_d1 = input.timeframe('3', title = 'Timeframe 2', group = 'Dashboard 1 - Timeframe Settings')
tf3_d1 = input.timeframe('5', title = 'Timeframe 3', group = 'Dashboard 1 - Timeframe Settings')
tf4_d1 = input.timeframe('15', title = 'Timeframe 4', group = 'Dashboard 1 - Timeframe Settings')
tf5_d1 = input.timeframe('30', title = 'Timeframe 5', group = 'Dashboard 1 - Timeframe Settings')

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* DASHBOARD 2 SETTINGS (MULTI-TIMEFRAME TREND TABLE) *//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

show_dashboard2 = input(true, title = "Show Dashboard 2 (Multi-Timeframe Trend)", group = 'Dashboard 2 - Multi-Timeframe Trend')

// === Dashboard 2 Inputs ===
fastLen_d2 = input.int(20, "Fast EMA Length", group="Dashboard 2 - EMA Settings")
slowLen_d2 = input.int(200, "Slow EMA Length", group="Dashboard 2 - EMA Settings")
showEMAs_d2 = input.bool(false, "Show EMAs on Chart", group="Dashboard 2 - Visualization")

fullScreenMode_d2 = input.bool(false, "Full Screen Table Mode", group="Dashboard 2 - Visualization")

// Table orientation setting
tableOrientation_d2 = input.string("Horizontal", "Table Orientation", options=["Horizontal", "Vertical"], group="Dashboard 2 - Visualization")

applyMADistanceToAlign_d2 = input.bool(true, "Only Align if MA Distance is XS/S/M", group="Dashboard 2 - Filters")
stochLen_d2 = input.int(8, "Stochastic Length", group="Dashboard 2 - Stochastic Settings")
stochOverbought_d2 = input.float(70.0, "Stoch Overbought", minval=0, maxval=100, group="Dashboard 2 - Stochastic Settings")
stochOversold_d2 = input.float(30.0, "Stoch Oversold", minval=0, maxval=100, group="Dashboard 2 - Stochastic Settings")
size_XS_d2 = input.float(0.25, "XS Threshold (ATR multiple)", group="Dashboard 2 - MA Distance Thresholds")
size_S_d2 = input.float(0.75, "S Threshold", group="Dashboard 2 - MA Distance Thresholds")
size_M_d2 = input.float(1.5, "M Threshold", group="Dashboard 2 - MA Distance Thresholds")
size_L_d2 = input.float(2.5, "L Threshold", group="Dashboard 2 - MA Distance Thresholds")

// Text size selection
textSizeOption_d2 = input.string("Normal", "Text Size", options=["Tiny", "Small", "Normal", "Large"], group="Dashboard 2 - Visualization")
textSize_d2 = textSizeOption_d2 == "Tiny" ? size.tiny :
           textSizeOption_d2 == "Small" ? size.small :
           textSizeOption_d2 == "Large" ? size.large : size.normal

// Fixed colors for headers and timeframes
headerColor_d2 = #2d383c
timeframeColor_d2 = #192428

// Fixed colors for MA Slope arrows
slopeUpColor_d2 = #0085ff      // Green for up arrow ↑
slopeDownColor_d2 = #ff0040    // Red for down arrow ↓
slopeSidewaysColor_d2 = #808080 // Gray for sideways arrow →

// Customizable timeframes with dropdown selection
tf1_option_d2 = input.string("2m", "Timeframe 1", options=["1m", "2m", "3m", "5m", "15m", "30m", "1H", "2H", "4H", "6H", "12H", "1D", "3D", "1W", "1M"], group="Dashboard 2 - Timeframe Settings")
tf2_option_d2 = input.string("5m", "Timeframe 2", options=["1m", "2m", "3m", "5m", "15m", "30m", "1H", "2H", "4H", "6H", "12H", "1D", "3D", "1W", "1M"], group="Dashboard 2 - Timeframe Settings")
tf3_option_d2 = input.string("15m", "Timeframe 3", options=["1m", "2m", "3m", "5m", "15m", "30m", "1H", "2H", "4H", "6H", "12H", "1D", "3D", "1W", "1M"], group="Dashboard 2 - Timeframe Settings")
tf4_option_d2 = input.string("1H", "Timeframe 4", options=["1m", "2m", "3m", "5m", "15m", "30m", "1H", "2H", "4H", "6H", "12H", "1D", "3D", "1W", "1M"], group="Dashboard 2 - Timeframe Settings")
tf5_option_d2 = input.string("4H", "Timeframe 5", options=["1m", "2m", "3m", "5m", "15m", "30m", "1H", "2H", "4H", "6H", "12H", "1D", "3D", "1W", "1M"], group="Dashboard 2 - Timeframe Settings")

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* DASHBOARD 1 CALCULATIONS *//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

var table_text_size_d1 = text_size_d1 == 'Normal' ? size.normal :
  text_size_d1 == 'Large' ? size.large :
  text_size_d1 == 'Tiny' ? size.tiny :
  text_size_d1 == 'Small' ? size.small : size.normal

var columns_count_d1 = show_pressure_gauge_d1 ? (show_ema_value_d1 ? 4 : 3) : (show_ema_value_d1 ? 3 : 2)

var t1 = table.new(position = position.top_right,
                  columns = columns_count_d1,
                  rows = 10,
                  frame_color = table_color_d1,
                  frame_width = 2,
                  border_color = table_color_d1,
                  border_width = 2)

calc_smma_d1(src, len) =>
    var float smma = na
    sma_val = ta.sma(src, len)
    smma := na(smma) ? sma_val : (smma[1] * (len - 1) + src) / len
    smma

calc_zlema_d1(src, len) =>
    ema1 = ta.ema(src, len)
    ema2 = ta.ema(ema1, len)
    d = ema1 - ema2
    ema1 + d

check_impulse_d1() =>
    impulse_length = 34
    impulse_strength = 9

    hi = calc_smma_d1(high, impulse_length)
    lo = calc_smma_d1(low, impulse_length)
    mi = calc_zlema_d1(hlc3, impulse_length)

    md = (mi > hi) ? (mi - hi) : (mi < lo) ? (mi - lo) : 0
    md_prev = (mi[1] > hi[1]) ? (mi[1] - hi[1]) : (mi[1] < lo[1]) ? (mi[1] - lo[1]) : 0

    sb = ta.sma(md, impulse_strength)
    sb_prev = ta.sma(md_prev, impulse_strength)

    sh = md - sb
    sh_prev = md_prev - sb_prev

    is_impulse = sh != 0 and sh_prev != 0
    is_impulse

compute_lengths_d1(lookback) =>
    red = 0
    green = 0
    scale = 25
    for i = 0 to lookback
        _range = (close[i] - open[i]) * volume[i]
        if _range > 0
            green += int(_range)
        else
            red += int(math.abs(_range))
    [red, green]

get_pressure_percentages_d1() =>
    [red, green] = compute_lengths_d1(lookback_pressure_d1)
    total = red + green
    if total > 0
        scale = 25
        dist_red = int((red / total) * scale)
        dist_green = scale - dist_red
        sell_percent = math.round(dist_red * (100/scale))
        buy_percent = math.round(dist_green * (100/scale))
        [sell_percent, buy_percent]
    else
        [50, 50]

get_trend_status_d1() =>
    impulse = catch_flat_d1 ? check_impulse_d1() : true
    ema1_current_candle = ta.ema(close, ema1_length_d1)
    ema1_previous_candle = ema1_current_candle[1]
    round = ema1_current_candle > 1000 ? 0 : ema1_current_candle > 10 ? 1 : ema1_current_candle > 0 ? 2 : ema1_current_candle > 0.1 ? 3 : 10
    ema1_str = str.tostring(math.round(ema1_current_candle, round))
    
    [sell_percent, buy_percent] = get_pressure_percentages_d1()
    pressure_str = str.tostring(sell_percent) + "% / " + str.tostring(buy_percent) + "%"
    
    pressure_trend_status = buy_percent > sell_percent ? 1 : buy_percent < sell_percent ? -1 : 0
    
    if (trend_identification_approach_d1 == "Direction of a single EMA")
        ema1_previous_previous_candle = ema1_current_candle[2]
        trend_status = not impulse ? 0 : ema1_current_candle > ema1_previous_candle ? 1 : ema1_current_candle < ema1_previous_candle ? -1 : 0
        trend_current_candle = not impulse ? neutraltrend_indicator_d1 : ema1_current_candle > ema1_previous_candle ? uptrend_indicator_d1 : ema1_current_candle < ema1_previous_candle ? downtrend_indicator_d1 : neutraltrend_indicator_d1
        trend_previous_candle = not impulse ? neutraltrend_indicator_d1 : ema1_previous_candle > ema1_previous_previous_candle ? uptrend_indicator_d1 : ema1_previous_candle < ema1_previous_previous_candle ? downtrend_indicator_d1 : neutraltrend_indicator_d1
        [ema1_str, trend_status, trend_current_candle, trend_previous_candle, pressure_str, pressure_trend_status]
    else
        ema2_current_candle = ta.ema(close, ema2_length_d1)
        ema2_previous_candle = ema2_current_candle[1]
        trend_status = not impulse ? 0 : ema1_current_candle > ema2_current_candle ? 1 : ema1_current_candle < ema2_current_candle ? -1 : 0
        trend_current_candle = not impulse ? neutraltrend_indicator_d1 : ema1_current_candle > ema2_current_candle ? uptrend_indicator_d1 : ema1_current_candle < ema2_current_candle ? downtrend_indicator_d1 : neutraltrend_indicator_d1
        trend_previous_candle = not impulse ? neutraltrend_indicator_d1 : ema1_previous_candle > ema2_previous_candle ? uptrend_indicator_d1 : ema1_previous_candle < ema2_previous_candle ? downtrend_indicator_d1 : neutraltrend_indicator_d1
        [ema1_str, trend_status, trend_current_candle, trend_previous_candle, pressure_str, pressure_trend_status]

get_trend_colors_d1(trend_status, pressure_trend_status) =>
    trend_bg = trend_status == 1 ? trend_uptrend_bg_color_d1 : trend_status == -1 ? trend_downtrend_bg_color_d1 : trend_neutraltrend_bg_color_d1
    ema_bg = trend_status == 1 ? ema_uptrend_bg_color_d1 : trend_status == -1 ? ema_downtrend_bg_color_d1 : ema_neutraltrend_bg_color_d1
    pressure_bg = pressure_trend_status == 1 ? pressure_uptrend_bg_color_d1 : pressure_trend_status == -1 ? pressure_downtrend_bg_color_d1 : pressure_neutraltrend_bg_color_d1
    [trend_bg, ema_bg, pressure_bg]

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* DASHBOARD 2 CALCULATIONS *//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Convert display labels to Pine Script timeframe format
getTFValue_d2(option) =>
    switch option
        "1m" => "1"
        "2m" => "2"
        "3m" => "3"
        "5m" => "5"
        "15m" => "15"
        "30m" => "30"
        "1H" => "60"
        "2H" => "120"
        "4H" => "240"
        "6H" => "360"
        "12H" => "720"
        "1D" => "D"
        "3D" => "3D"
        "1W" => "W"
        "1M" => "M"
        => "5"

tf1_d2 = getTFValue_d2(tf1_option_d2)
tf1_label_d2 = tf1_option_d2
tf2_d2 = getTFValue_d2(tf2_option_d2)
tf2_label_d2 = tf2_option_d2
tf3_d2 = getTFValue_d2(tf3_option_d2)
tf3_label_d2 = tf3_option_d2
tf4_d2 = getTFValue_d2(tf4_option_d2)
tf4_label_d2 = tf4_option_d2
tf5_d2 = getTFValue_d2(tf5_option_d2)
tf5_label_d2 = tf5_option_d2

getTrend_d2(f, s) => f > s ? 1 : f < s ? -1 : 0

getTFData_d2(tf) =>
    [f, s, st, c, a, m, sig, htf50, htf200] = request.security(syminfo.tickerid, tf, [ta.ema(close, fastLen_d2), ta.ema(close, slowLen_d2), ta.stoch(close, high, low, stochLen_d2), close, ta.atr(14), ta.ema(close, 12) - ta.ema(close, 26), ta.ema(ta.ema(close, 12) - ta.ema(close, 26), 9), ta.ema(close, 50), ta.ema(close, 200)])

    t = getTrend_d2(f, s)
    slope = f - request.security(syminfo.tickerid, tf, ta.ema(close[5], fastLen_d2))
    sl = slope > 0 ? "↑" : slope < 0 ? "↓" : "→"
    slBg = slope > 0 ? slopeUpColor_d2 : slope < 0 ? slopeDownColor_d2 : slopeSidewaysColor_d2
    pos = c > f and c > s ? "🔼" : c < f and c < s ? "🔽" : "-"
    d = t == 1 and c > f ? (c - f) / a : t == -1 and c < f ? (f - c) / a : na
    dl = na(d) ? "-" : d < size_XS_d2 ? "XS" : d < size_S_d2 ? "S" : d < size_M_d2 ? "M" : d < size_L_d2 ? "L" : "XL"
    dc = na(d) ? color.gray : d < size_XS_d2 ? #1c23a6 : d < size_S_d2 ? #1c23a6 : d < size_M_d2 ? #1c23a6 : d < size_L_d2 ? color.orange : color.red
    dcText = (t == 1 and d < size_M_d2) or (t == -1 and d < size_M_d2) ? color.white : dc
    ce = not na(d) and d < size_M_d2
    trendCond = (t == 1 and c > f and c > s) or (t == -1 and c < f and c < s)
    stochCond = (t == 1 and st < stochOverbought_d2) or (t == -1 and st > stochOverbought_d2)
    baseAlign = trendCond and stochCond
    al = applyMADistanceToAlign_d2 ? (baseAlign and ce) : baseAlign
    alignSymbol = al ? "✔" : "x"
    alignTooltip = al ? "Conditions met" : "Missing: " + (not trendCond ? "price in trend dir; " : "") + (not stochCond ? "stoch within bounds; " : "") + (not ce ? "distance XS/S/M;" : "")
    macdUp = m > sig
    htfUp = htf50 > htf200
    macdStr = macdUp ? "🟢" : "🔴"
    macdCol = macdUp ? color.green : color.red
    score = 0.0
    score := f > s ? score + 20 : score
    score := slope > 0 ? score + 20 : score
    score := macdUp ? score + 20 : score
    score := c > f ? score + 20 : score
    score := htfUp ? score + 20 : score
    [t, d, math.round(st), sl, al, alignSymbol, alignTooltip, dl, dc, dcText, pos, macdStr, macdCol, score, c > f and c > s, c < f and c < s, slBg]

// Create table with dynamic dimensions based on orientation
var table tTable_d2 = na
if na(tTable_d2) and show_dashboard2
    if tableOrientation_d2 == "Vertical"
        tTable_d2 := table.new(fullScreenMode_d2 ? position.middle_center : position.bottom_right, 6, 9, border_width=1)
    else
        tTable_d2 := table.new(fullScreenMode_d2 ? position.middle_center : position.bottom_right, 9, 6, border_width=1)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* DASHBOARD 1 TABLE RENDERING *//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Get Dashboard 1 data (moved outside conditional structure)
[ema_tf1_d1, trend_status_tf1_d1, trend_indicator_tf1_d1, _, pressure_tf1_d1, pressure_trend_status_tf1_d1] = request.security(syminfo.tickerid, tf1_d1, get_trend_status_d1())
[ema_tf2_d1, trend_status_tf2_d1, trend_indicator_tf2_d1, _, pressure_tf2_d1, pressure_trend_status_tf2_d1] = request.security(syminfo.tickerid, tf2_d1, get_trend_status_d1())
[ema_tf3_d1, trend_status_tf3_d1, trend_indicator_tf3_d1, _, pressure_tf3_d1, pressure_trend_status_tf3_d1] = request.security(syminfo.tickerid, tf3_d1, get_trend_status_d1())
[ema_tf4_d1, trend_status_tf4_d1, trend_indicator_tf4_d1, _, pressure_tf4_d1, pressure_trend_status_tf4_d1] = request.security(syminfo.tickerid, tf4_d1, get_trend_status_d1())
[ema_tf5_d1, trend_status_tf5_d1, trend_indicator_tf5_d1, _, pressure_tf5_d1, pressure_trend_status_tf5_d1] = request.security(syminfo.tickerid, tf5_d1, get_trend_status_d1())

[trend_bg_tf1_d1, ema_bg_tf1_d1, pressure_bg_tf1_d1] = get_trend_colors_d1(trend_status_tf1_d1, pressure_trend_status_tf1_d1)
[trend_bg_tf2_d1, ema_bg_tf2_d1, pressure_bg_tf2_d1] = get_trend_colors_d1(trend_status_tf2_d1, pressure_trend_status_tf2_d1)
[trend_bg_tf3_d1, ema_bg_tf3_d1, pressure_bg_tf3_d1] = get_trend_colors_d1(trend_status_tf3_d1, pressure_trend_status_tf3_d1)
[trend_bg_tf4_d1, ema_bg_tf4_d1, pressure_bg_tf4_d1] = get_trend_colors_d1(trend_status_tf4_d1, pressure_trend_status_tf4_d1)
[trend_bg_tf5_d1, ema_bg_tf5_d1, pressure_bg_tf5_d1] = get_trend_colors_d1(trend_status_tf5_d1, pressure_trend_status_tf5_d1)

if show_dashboard1

    if (barstate.islast)
        column_index = 0
        
        if (show_header_d1)
            table.cell(t1, column_index, 0, "Timeframe", text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = header_bg_color_d1)
            column_index += 1
            table.cell(t1, column_index, 0, "Trend", text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = header_bg_color_d1)
            column_index += 1
            if (show_ema_value_d1)
                table.cell(t1, column_index, 0, str.tostring(ema1_length_d1) + " EMA", text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = header_bg_color_d1)
                column_index += 1
            if (show_pressure_gauge_d1)
                table.cell(t1, column_index, 0, "Pressure (S/B)", text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = header_bg_color_d1)

        // Dashboard 1 Rows
        column_index := 0
        table.cell(t1, column_index, 1, tf1_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = tf_bg_color_d1)
        column_index += 1
        table.cell(t1, column_index, 1, trend_indicator_tf1_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = trend_bg_tf1_d1)
        column_index += 1
        if (show_ema_value_d1)
            table.cell(t1, column_index, 1, ema_tf1_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = ema_bg_tf1_d1)
            column_index += 1
        if (show_pressure_gauge_d1)
            table.cell(t1, column_index, 1, pressure_tf1_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = pressure_bg_tf1_d1)

        // Row 2 - TF2
        column_index := 0
        table.cell(t1, column_index, 2, tf2_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = tf_bg_color_d1)
        column_index += 1
        table.cell(t1, column_index, 2, trend_indicator_tf2_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = trend_bg_tf2_d1)
        column_index += 1
        if (show_ema_value_d1)
            table.cell(t1, column_index, 2, ema_tf2_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = ema_bg_tf2_d1)
            column_index += 1
        if (show_pressure_gauge_d1)
            table.cell(t1, column_index, 2, pressure_tf2_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = pressure_bg_tf2_d1)

        // Row 3 - TF3
        column_index := 0
        table.cell(t1, column_index, 3, tf3_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = tf_bg_color_d1)
        column_index += 1
        table.cell(t1, column_index, 3, trend_indicator_tf3_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = trend_bg_tf3_d1)
        column_index += 1
        if (show_ema_value_d1)
            table.cell(t1, column_index, 3, ema_tf3_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = ema_bg_tf3_d1)
            column_index += 1
        if (show_pressure_gauge_d1)
            table.cell(t1, column_index, 3, pressure_tf3_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = pressure_bg_tf3_d1)

        // Row 4 - TF4
        column_index := 0
        table.cell(t1, column_index, 4, tf4_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = tf_bg_color_d1)
        column_index += 1
        table.cell(t1, column_index, 4, trend_indicator_tf4_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = trend_bg_tf4_d1)
        column_index += 1
        if (show_ema_value_d1)
            table.cell(t1, column_index, 4, ema_tf4_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = ema_bg_tf4_d1)
            column_index += 1
        if (show_pressure_gauge_d1)
            table.cell(t1, column_index, 4, pressure_tf4_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = pressure_bg_tf4_d1)

        // Row 5 - TF5
        column_index := 0
        table.cell(t1, column_index, 5, tf5_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = tf_bg_color_d1)
        column_index += 1
        table.cell(t1, column_index, 5, trend_indicator_tf5_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = trend_bg_tf5_d1)
        column_index += 1
        if (show_ema_value_d1)
            table.cell(t1, column_index, 5, ema_tf5_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = ema_bg_tf5_d1)
            column_index += 1
        if (show_pressure_gauge_d1)
            table.cell(t1, column_index, 5, pressure_tf5_d1, text_color = text_color_d1, text_size = table_text_size_d1, bgcolor = pressure_bg_tf5_d1)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* DASHBOARD 2 TABLE RENDERING *//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Headers arrays
var string[] horizontalHeaders_d2 = array.from("TF", "Trend", "Price Pos", "MA Distance", "Stoch", "Align", "MA Slope", "Trend %", "Macd")
var string[] verticalHeaders_d2 = array.from("TF", "Trend", "Price Pos", "MA Distance", "Stoch", "Align", "MA Slope", "Trend %", "Macd")

// Initialize headers based on orientation for Dashboard 2
if bar_index == 1 and show_dashboard2 and not na(tTable_d2)
    if tableOrientation_d2 == "Horizontal"
        for i = 0 to array.size(horizontalHeaders_d2) - 1
            table.cell(tTable_d2, i, 0, array.get(horizontalHeaders_d2, i), text_color=color.white, bgcolor=headerColor_d2, text_halign=text.align_center, text_size=textSize_d2)
    else
        // Vertical orientation: Row headers in first column (starting from row 1)
        table.cell(tTable_d2, 0, 1, "Trend", text_color=color.white, bgcolor=headerColor_d2, text_halign=text.align_center, text_size=textSize_d2)
        table.cell(tTable_d2, 0, 2, "Price Pos", text_color=color.white, bgcolor=headerColor_d2, text_halign=text.align_center, text_size=textSize_d2)
        table.cell(tTable_d2, 0, 3, "MA Distance", text_color=color.white, bgcolor=headerColor_d2, text_halign=text.align_center, text_size=textSize_d2)
        table.cell(tTable_d2, 0, 4, "Stoch", text_color=color.white, bgcolor=headerColor_d2, text_halign=text.align_center, text_size=textSize_d2)
        table.cell(tTable_d2, 0, 5, "Align", text_color=color.white, bgcolor=headerColor_d2, text_halign=text.align_center, text_size=textSize_d2)
        table.cell(tTable_d2, 0, 6, "MA Slope", text_color=color.white, bgcolor=headerColor_d2, text_halign=text.align_center, text_size=textSize_d2)
        table.cell(tTable_d2, 0, 7, "Trend %", text_color=color.white, bgcolor=headerColor_d2, text_halign=text.align_center, text_size=textSize_d2)
        table.cell(tTable_d2, 0, 8, "Macd", text_color=color.white, bgcolor=headerColor_d2, text_halign=text.align_center, text_size=textSize_d2)

renderRowHorizontal_d2(r, lbl, t, d, st, sl, a, alignSymbol, alignTooltip, dl, dc, dcText, pos, macdStr, macdCol, score, aboveBoth, belowBoth, slBg) =>
    ts = t == 1 ? "↑" : t == -1 ? "↓" : "→"
    tc = t == 1 ? #00ff00 : t == -1 ? #ff0000 : color.orange
    trendCol = score >= 80 ? color.rgb(1, 236, 40) : score >= 60 ? #008c45 : score >= 40 ? color.orange : color.gray
    stBg = t == 1 and st <= stochOversold_d2 ? #03cdff : t == -1 and st >= stochOverbought_d2 ? #ff0080 : na
    stFg = na(stBg) ? color.white : color.white
    posBg = t == 1 and aboveBoth and d < size_M_d2 ? #0080ff : t == -1 and belowBoth and d < size_M_d2 ? #ff0033 : na
    posEmoji = t == 1 and aboveBoth ? "🔼" : t == -1 and belowBoth ? "🔽" : "-"
    alignBg = a and t == -1 ? #e40303 : a and t == 1 ? #008026 : na
    rowBg = r % 2 == 0 ? color.new(color.rgb(68, 71, 90), 0) : color.new(color.rgb(40, 42, 54), 0)

    table.cell(tTable_d2, 0, r, lbl, text_color=color.white, bgcolor=timeframeColor_d2, text_halign=text.align_center, text_size=textSize_d2)
    table.cell(tTable_d2, 1, r, ts, bgcolor=tc, text_color=color.white, text_halign=text.align_center, text_size=textSize_d2)
    table.cell(tTable_d2, 2, r, posEmoji, bgcolor=na(posBg) ? rowBg : posBg, text_color=color.white, text_halign=text.align_center, text_size=textSize_d2)
    table.cell(tTable_d2, 3, r, dl, text_color=dcText, bgcolor=(t == 1 and aboveBoth and d < size_M_d2) ? #0027ff : (t == -1 and belowBoth and d < size_M_d2) ? #bf0637 : rowBg, text_halign=text.align_center, text_size=textSize_d2)
    table.cell(tTable_d2, 4, r, str.tostring(st), text_color=stFg, bgcolor=na(stBg) ? rowBg : stBg, text_halign=text.align_center, text_size=textSize_d2)
    table.cell(tTable_d2, 5, r, alignSymbol, bgcolor=na(alignBg) ? rowBg : alignBg, text_color=color.white, text_halign=text.align_center, tooltip=alignTooltip, text_size=textSize_d2)
    table.cell(tTable_d2, 6, r, sl, text_color=color.white, bgcolor=slBg, text_halign=text.align_center, text_size=textSize_d2)
    table.cell(tTable_d2, 7, r, str.tostring(score, format.percent), bgcolor=trendCol, text_color=color.white, text_halign=text.align_center, text_size=textSize_d2)
    table.cell(tTable_d2, 8, r, macdStr, bgcolor=rowBg, text_color=macdCol, text_halign=text.align_center, text_size=textSize_d2)

renderRowVertical_d2(c, lbl, t, d, st, sl, a, alignSymbol, alignTooltip, dl, dc, dcText, pos, macdStr, macdCol, score, aboveBoth, belowBoth, slBg) =>
    ts = t == 1 ? "↑" : t == -1 ? "↓" : "→"
    tc = t == 1 ? #00ff00 : t == -1 ? #ff0000 : color.orange
    trendCol = score >= 80 ? color.rgb(1, 236, 40) : score >= 60 ? #008c45 : score >= 40 ? color.orange : color.gray
    stBg = t == 1 and st <= stochOversold_d2 ? #03cdff : t == -1 and st >= stochOverbought_d2 ? #ff0080 : na
    stFg = na(stBg) ? color.white : color.white
    posBg = t == 1 and aboveBoth and d < size_M_d2 ? #0080ff : t == -1 and belowBoth and d < size_M_d2 ? #ff0033 : na
    posEmoji = t == 1 and aboveBoth ? "🔼" : t == -1 and belowBoth ? "🔽" : "-"
    alignBg = a and t == -1 ? #e40303 : a and t == 1 ? #008026 : na
    colBg = c % 2 == 0 ? color.new(color.rgb(68, 71, 90), 0) : color.new(color.rgb(40, 42, 54), 0)

    // In vertical mode: timeframes are column headers (row 0), data in rows 1-8
    table.cell(tTable_d2, c, 0, lbl, text_color=color.white, bgcolor=timeframeColor_d2, text_halign=text.align_center, text_size=textSize_d2)  // Timeframe header
    table.cell(tTable_d2, c, 1, ts, bgcolor=tc, text_color=color.white, text_halign=text.align_center, text_size=textSize_d2)              // Trend
    table.cell(tTable_d2, c, 2, posEmoji, bgcolor=na(posBg) ? colBg : posBg, text_color=color.white, text_halign=text.align_center, text_size=textSize_d2)  // Price Pos
    table.cell(tTable_d2, c, 3, dl, text_color=dcText, bgcolor=(t == 1 and aboveBoth and d < size_M_d2) ? #0027ff : (t == -1 and belowBoth and d < size_M_d2) ? #bf0637 : colBg, text_halign=text.align_center, text_size=textSize_d2)  // MA Distance
    table.cell(tTable_d2, c, 4, str.tostring(st), text_color=stFg, bgcolor=na(stBg) ? colBg : stBg, text_halign=text.align_center, text_size=textSize_d2)  // Stoch
    table.cell(tTable_d2, c, 5, alignSymbol, bgcolor=na(alignBg) ? colBg : alignBg, text_color=color.white, text_halign=text.align_center, tooltip=alignTooltip, text_size=textSize_d2)  // Align
    table.cell(tTable_d2, c, 6, sl, text_color=color.white, bgcolor=slBg, text_halign=text.align_center, text_size=textSize_d2)           // MA Slope
    table.cell(tTable_d2, c, 7, str.tostring(score, format.percent), bgcolor=trendCol, text_color=color.white, text_halign=text.align_center, text_size=textSize_d2)  // Trend %
    table.cell(tTable_d2, c, 8, macdStr, bgcolor=colBg, text_color=macdCol, text_halign=text.align_center, text_size=textSize_d2)          // Macd

renderTimeframeRow_d2(index, lbl, tf) =>
    [t, d, st, sl, a, alignSymbol, alignTooltip, dl, dc, dcText, pos, macdStr, macdCol, score, aboveBoth, belowBoth, slBg] = getTFData_d2(tf)
    if tableOrientation_d2 == "Horizontal"
        renderRowHorizontal_d2(index, lbl, t, d, st, sl, a, alignSymbol, alignTooltip, dl, dc, dcText, pos, macdStr, macdCol, score, aboveBoth, belowBoth, slBg)
    else
        renderRowVertical_d2(index, lbl, t, d, st, sl, a, alignSymbol, alignTooltip, dl, dc, dcText, pos, macdStr, macdCol, score, aboveBoth, belowBoth, slBg)

// Get Dashboard 2 data (moved outside conditional structure)  
[tf1_data_d2_t, tf1_data_d2_d, tf1_data_d2_st, tf1_data_d2_sl, tf1_data_d2_a, tf1_data_d2_alignSymbol, tf1_data_d2_alignTooltip, tf1_data_d2_dl, tf1_data_d2_dc, tf1_data_d2_dcText, tf1_data_d2_pos, tf1_data_d2_macdStr, tf1_data_d2_macdCol, tf1_data_d2_score, tf1_data_d2_aboveBoth, tf1_data_d2_belowBoth, tf1_data_d2_slBg] = getTFData_d2(tf1_d2)
[tf2_data_d2_t, tf2_data_d2_d, tf2_data_d2_st, tf2_data_d2_sl, tf2_data_d2_a, tf2_data_d2_alignSymbol, tf2_data_d2_alignTooltip, tf2_data_d2_dl, tf2_data_d2_dc, tf2_data_d2_dcText, tf2_data_d2_pos, tf2_data_d2_macdStr, tf2_data_d2_macdCol, tf2_data_d2_score, tf2_data_d2_aboveBoth, tf2_data_d2_belowBoth, tf2_data_d2_slBg] = getTFData_d2(tf2_d2)
[tf3_data_d2_t, tf3_data_d2_d, tf3_data_d2_st, tf3_data_d2_sl, tf3_data_d2_a, tf3_data_d2_alignSymbol, tf3_data_d2_alignTooltip, tf3_data_d2_dl, tf3_data_d2_dc, tf3_data_d2_dcText, tf3_data_d2_pos, tf3_data_d2_macdStr, tf3_data_d2_macdCol, tf3_data_d2_score, tf3_data_d2_aboveBoth, tf3_data_d2_belowBoth, tf3_data_d2_slBg] = getTFData_d2(tf3_d2)
[tf4_data_d2_t, tf4_data_d2_d, tf4_data_d2_st, tf4_data_d2_sl, tf4_data_d2_a, tf4_data_d2_alignSymbol, tf4_data_d2_alignTooltip, tf4_data_d2_dl, tf4_data_d2_dc, tf4_data_d2_dcText, tf4_data_d2_pos, tf4_data_d2_macdStr, tf4_data_d2_macdCol, tf4_data_d2_score, tf4_data_d2_aboveBoth, tf4_data_d2_belowBoth, tf4_data_d2_slBg] = getTFData_d2(tf4_d2)
[tf5_data_d2_t, tf5_data_d2_d, tf5_data_d2_st, tf5_data_d2_sl, tf5_data_d2_a, tf5_data_d2_alignSymbol, tf5_data_d2_alignTooltip, tf5_data_d2_dl, tf5_data_d2_dc, tf5_data_d2_dcText, tf5_data_d2_pos, tf5_data_d2_macdStr, tf5_data_d2_macdCol, tf5_data_d2_score, tf5_data_d2_aboveBoth, tf5_data_d2_belowBoth, tf5_data_d2_slBg] = getTFData_d2(tf5_d2)

// Render Dashboard 2 timeframe rows
if show_dashboard2 and not na(tTable_d2)
    if tableOrientation_d2 == "Horizontal"
        renderRowHorizontal_d2(1, tf1_label_d2, tf1_data_d2_t, tf1_data_d2_d, tf1_data_d2_st, tf1_data_d2_sl, tf1_data_d2_a, tf1_data_d2_alignSymbol, tf1_data_d2_alignTooltip, tf1_data_d2_dl, tf1_data_d2_dc, tf1_data_d2_dcText, tf1_data_d2_pos, tf1_data_d2_macdStr, tf1_data_d2_macdCol, tf1_data_d2_score, tf1_data_d2_aboveBoth, tf1_data_d2_belowBoth, tf1_data_d2_slBg)
        renderRowHorizontal_d2(2, tf2_label_d2, tf2_data_d2_t, tf2_data_d2_d, tf2_data_d2_st, tf2_data_d2_sl, tf2_data_d2_a, tf2_data_d2_alignSymbol, tf2_data_d2_alignTooltip, tf2_data_d2_dl, tf2_data_d2_dc, tf2_data_d2_dcText, tf2_data_d2_pos, tf2_data_d2_macdStr, tf2_data_d2_macdCol, tf2_data_d2_score, tf2_data_d2_aboveBoth, tf2_data_d2_belowBoth, tf2_data_d2_slBg)
        renderRowHorizontal_d2(3, tf3_label_d2, tf3_data_d2_t, tf3_data_d2_d, tf3_data_d2_st, tf3_data_d2_sl, tf3_data_d2_a, tf3_data_d2_alignSymbol, tf3_data_d2_alignTooltip, tf3_data_d2_dl, tf3_data_d2_dc, tf3_data_d2_dcText, tf3_data_d2_pos, tf3_data_d2_macdStr, tf3_data_d2_macdCol, tf3_data_d2_score, tf3_data_d2_aboveBoth, tf3_data_d2_belowBoth, tf3_data_d2_slBg)
        renderRowHorizontal_d2(4, tf4_label_d2, tf4_data_d2_t, tf4_data_d2_d, tf4_data_d2_st, tf4_data_d2_sl, tf4_data_d2_a, tf4_data_d2_alignSymbol, tf4_data_d2_alignTooltip, tf4_data_d2_dl, tf4_data_d2_dc, tf4_data_d2_dcText, tf4_data_d2_pos, tf4_data_d2_macdStr, tf4_data_d2_macdCol, tf4_data_d2_score, tf4_data_d2_aboveBoth, tf4_data_d2_belowBoth, tf4_data_d2_slBg)
        renderRowHorizontal_d2(5, tf5_label_d2, tf5_data_d2_t, tf5_data_d2_d, tf5_data_d2_st, tf5_data_d2_sl, tf5_data_d2_a, tf5_data_d2_alignSymbol, tf5_data_d2_alignTooltip, tf5_data_d2_dl, tf5_data_d2_dc, tf5_data_d2_dcText, tf5_data_d2_pos, tf5_data_d2_macdStr, tf5_data_d2_macdCol, tf5_data_d2_score, tf5_data_d2_aboveBoth, tf5_data_d2_belowBoth, tf5_data_d2_slBg)
    else
        // Vertical mode: columns 1-5 for timeframes
        renderRowVertical_d2(1, tf1_label_d2, tf1_data_d2_t, tf1_data_d2_d, tf1_data_d2_st, tf1_data_d2_sl, tf1_data_d2_a, tf1_data_d2_alignSymbol, tf1_data_d2_alignTooltip, tf1_data_d2_dl, tf1_data_d2_dc, tf1_data_d2_dcText, tf1_data_d2_pos, tf1_data_d2_macdStr, tf1_data_d2_macdCol, tf1_data_d2_score, tf1_data_d2_aboveBoth, tf1_data_d2_belowBoth, tf1_data_d2_slBg)
        renderRowVertical_d2(2, tf2_label_d2, tf2_data_d2_t, tf2_data_d2_d, tf2_data_d2_st, tf2_data_d2_sl, tf2_data_d2_a, tf2_data_d2_alignSymbol, tf2_data_d2_alignTooltip, tf2_data_d2_dl, tf2_data_d2_dc, tf2_data_d2_dcText, tf2_data_d2_pos, tf2_data_d2_macdStr, tf2_data_d2_macdCol, tf2_data_d2_score, tf2_data_d2_aboveBoth, tf2_data_d2_belowBoth, tf2_data_d2_slBg)
        renderRowVertical_d2(3, tf3_label_d2, tf3_data_d2_t, tf3_data_d2_d, tf3_data_d2_st, tf3_data_d2_sl, tf3_data_d2_a, tf3_data_d2_alignSymbol, tf3_data_d2_alignTooltip, tf3_data_d2_dl, tf3_data_d2_dc, tf3_data_d2_dcText, tf3_data_d2_pos, tf3_data_d2_macdStr, tf3_data_d2_macdCol, tf3_data_d2_score, tf3_data_d2_aboveBoth, tf3_data_d2_belowBoth, tf3_data_d2_slBg)
        renderRowVertical_d2(4, tf4_label_d2, tf4_data_d2_t, tf4_data_d2_d, tf4_data_d2_st, tf4_data_d2_sl, tf4_data_d2_a, tf4_data_d2_alignSymbol, tf4_data_d2_alignTooltip, tf4_data_d2_dl, tf4_data_d2_dc, tf4_data_d2_dcText, tf4_data_d2_pos, tf4_data_d2_macdStr, tf4_data_d2_macdCol, tf4_data_d2_score, tf4_data_d2_aboveBoth, tf4_data_d2_belowBoth, tf4_data_d2_slBg)
        renderRowVertical_d2(5, tf5_label_d2, tf5_data_d2_t, tf5_data_d2_d, tf5_data_d2_st, tf5_data_d2_sl, tf5_data_d2_a, tf5_data_d2_alignSymbol, tf5_data_d2_alignTooltip, tf5_data_d2_dl, tf5_data_d2_dc, tf5_data_d2_dcText, tf5_data_d2_pos, tf5_data_d2_macdStr, tf5_data_d2_macdCol, tf5_data_d2_score, tf5_data_d2_aboveBoth, tf5_data_d2_belowBoth, tf5_data_d2_slBg)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* DASHBOARD 1 ALERTS *//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

[_, _, current_trend_indicator_current_timeframe_d1, previous_trend_indicator_current_timeframe_d1, _, _] = get_trend_status_d1()

// Get data for alignment alerts (move outside of if condition)
[_, trend_status_tf1_d1_alert, trend_indicator_tf1_d1_alert, _, _, _] = request.security(syminfo.tickerid, tf1_d1, get_trend_status_d1())
[_, trend_status_tf2_d1_alert, trend_indicator_tf2_d1_alert, _, _, _] = request.security(syminfo.tickerid, tf2_d1, get_trend_status_d1())
[_, trend_status_tf3_d1_alert, trend_indicator_tf3_d1_alert, _, _, _] = request.security(syminfo.tickerid, tf3_d1, get_trend_status_d1())
[_, trend_status_tf4_d1_alert, trend_indicator_tf4_d1_alert, _, _, _] = request.security(syminfo.tickerid, tf4_d1, get_trend_status_d1())
[_, trend_status_tf5_d1_alert, trend_indicator_tf5_d1_alert, _, _, _] = request.security(syminfo.tickerid, tf5_d1, get_trend_status_d1())

alertcondition(current_trend_indicator_current_timeframe_d1 != previous_trend_indicator_current_timeframe_d1, 'Dashboard 1 - Trend changed', '⏰ Trend changed on {{ticker}}:{{interval}}min')
alertcondition(current_trend_indicator_current_timeframe_d1 != previous_trend_indicator_current_timeframe_d1 and current_trend_indicator_current_timeframe_d1 == uptrend_indicator_d1, 'Dashboard 1 - Uptrend started', '🟢 Uptrend started on {{ticker}}:{{interval}}min')
alertcondition(current_trend_indicator_current_timeframe_d1 != previous_trend_indicator_current_timeframe_d1 and current_trend_indicator_current_timeframe_d1 == downtrend_indicator_d1, 'Dashboard 1 - Downtrend started', '🔴 Downtrend started on {{ticker}}:{{interval}}min')
alertcondition(current_trend_indicator_current_timeframe_d1 != previous_trend_indicator_current_timeframe_d1 and current_trend_indicator_current_timeframe_d1 == neutraltrend_indicator_d1, 'Dashboard 1 - Neutral trend started', '⚫️ Neutral trend started on {{ticker}}:{{interval}}min')
alertcondition(trend_indicator_tf3_d1_alert == trend_indicator_tf4_d1_alert and trend_indicator_tf4_d1_alert == trend_indicator_tf5_d1_alert, 'Dashboard 1 - TF3, TF4, TF5 aligned', 'TF3, TF4, TF5 {{ticker}} trend alignment')
alertcondition(trend_indicator_tf2_d1_alert == trend_indicator_tf3_d1_alert and trend_indicator_tf3_d1_alert == trend_indicator_tf4_d1_alert, 'Dashboard 1 - TF2, TF3, TF4 aligned', 'TF2, TF3, TF4 {{ticker}} trend alignment')
alertcondition(trend_indicator_tf1_d1_alert == trend_indicator_tf2_d1_alert and trend_indicator_tf2_d1_alert == trend_indicator_tf3_d1_alert, 'Dashboard 1 - TF1, TF2, TF3 aligned', 'TF1, TF2, TF3 {{ticker}} trend alignment')
alertcondition(trend_indicator_tf1_d1_alert == trend_indicator_tf2_d1_alert and trend_indicator_tf2_d1_alert == trend_indicator_tf3_d1_alert and trend_indicator_tf3_d1_alert == trend_indicator_tf4_d1_alert, 'Dashboard 1 - TF1, TF2, TF3, TF4 aligned', 'TF1, TF2, TF3, TF4 {{ticker}} trend alignment')
alertcondition(trend_indicator_tf1_d1_alert == trend_indicator_tf2_d1_alert and trend_indicator_tf2_d1_alert == trend_indicator_tf3_d1_alert and trend_indicator_tf3_d1_alert == trend_indicator_tf4_d1_alert and trend_indicator_tf4_d1_alert == trend_indicator_tf5_d1_alert, 'Dashboard 1 - All timeframes aligned', 'All timeframes {{ticker}} trend alignment')

//@version=5
slen = input.int(24, 'Short Horizon', minval=1)
mlen = input(120, 'Medium Horizon')
llen = input(480, 'Longer dummy')

calculate_sum(i_range, isBullish) =>
    if isBullish
        math.sum(close >= open ? ohlc4 : 0, i_range)
    else
        math.sum(close <= open ? ohlc4 : 0, i_range)

calculate_percentage(sum, total_sum) =>
    sum / total_sum * 100

var table probtab = table.new(position.bottom_left, 3, 4, border_width=2)

// Tạo tiêu đề bảng
table.cell(probtab, 0, 0, text='BASED ON', bgcolor=#130491, text_color=color.white, text_size=size.small)
table.cell(probtab, 1, 0, text='P(▲)', bgcolor=#130491, text_color=color.white, text_size=size.small)
table.cell(probtab, 2, 0, text='P(▼)', bgcolor=#130491, text_color=color.white, text_size=size.small)

for i = 1 to 3
    dummy = i == 1 ? slen : i == 2 ? mlen : llen
    range_sum = math.sum(ohlc4, dummy)
    bullish_sum = calculate_sum(dummy, true)
    bearish_sum = calculate_sum(dummy, false)
    bullish_percentage = calculate_percentage(bullish_sum, range_sum)
    bearish_percentage = calculate_percentage(bearish_sum, range_sum)

    // Màu sắc cho các trường hợp
    lime_color = i == 1 ? #00ff00 : i == 2 ? #00ff00 : #00ff00
    red_color = i == 1 ? #ff0000 : i == 2 ? #ff0000 : #ff0000
    gray_black_color = #2b2b2b

    // Đặt màu sắc cho P(▲) và P(▼)
    bullish_bgcolor = bullish_percentage > bearish_percentage ? lime_color : gray_black_color
    bearish_bgcolor = bearish_percentage > bullish_percentage ? red_color : gray_black_color

    table.cell(probtab, 0, i, text=str.tostring(dummy) + ' BARS', bgcolor=#bce4ff, text_color=#131722, text_size=size.small)
    table.cell(probtab, 1, i, text=str.tostring(math.round(bullish_percentage, 2)) + '%', bgcolor=bullish_bgcolor, text_color=color.white, text_size=size.small)
    table.cell(probtab, 2, i, text=str.tostring(math.round(bearish_percentage, 2)) + '%', bgcolor=bearish_bgcolor, text_color=color.white, text_size=size.small)